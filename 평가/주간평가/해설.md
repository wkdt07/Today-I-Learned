# 한 문제를 오래 본다고 실력이 느는게 아니다, 문제를 많이 풀어봐야함.

# 1 보너스 점수

```py
# SHB
T = int(input())

for t in range(1,T+1):
    N = int(input())
    arr = [list(map(int,input().split())) for _ in range(N)]
    di = [1,-1,0,0] # 상하
    dj = [0,0,1,-1] # 좌우

    sum_lst = [] #보너스 점수 모음

    for i in range(N):
        for j in range(N):
            sum_v = 0 # 보너스 점수
            max_v = 0
            if (i != 0) and (j != 0) and (i != N - 1) and (j != N - 1): # 만약 i,j 가 가장자리라면 그냥 sum_v(보너스점수)는 0
                for k in range(4):
                    ni = i + di[k]
                    nj = j + dj[k]

                    if (0<=ni<N) and (0<=nj<N): # 인덱스를 벗어나지 않도록
                        sum_v += arr[ni][nj] # 상하좌우의 합
                sum_v -= arr[i][j] #상하좌우를 합친 값에서 맞힌 부분을 뺀다
                if sum_v % 2 == 0: # 2의 배수라면 2배
                    sum_v *= 2
                if sum_v < 0 : # 음수라면 0
                    sum_v = 0

            sum_lst.append(sum_v)

    sum_lst.sort() # sum_lst 오름차순 정리

    max_v = sum_lst[len(sum_lst)-1] # 정렬된 sum_lst의 마지막 항이 최댓값

    print(f'#{t} {max_v}') # 보너스 점수 모음 중 최대값 출력

```

```py
T = int(input())

for t in range(1,T+1):
    N = int(input())
    arr = [list(map(int,input().split())) for _ in range(N)]
    di = [1,-1,0,0] # 상하
    dj = [0,0,1,-1] # 좌우

    sum_lst = [] #보너스 점수 모음

    for i in range(N):
        for j in range(N):
            sum_v = 0 # 보너스 점수
            max_v = 0
```


```py
T = int(input())

for t in range(1,T+1):
    N = int(input())
    arr = [list(map(int,input().split())) for _ in range(N)]
    max_v = 0

    for i in range(1,N-1): #애초에 가장자리로 처리 
        for j in range(1,N-1): 
            bonus = arr[i][j+1] +arr[i+1][j] + arr[i][j-1] + arr[i-1][j] - arr[i][j]
            if bonus >0:    
                if bonus%2 == 0:
                    bonus *= 2
            if max_v < bonus:
                max_v = bonus
    print(f'#{t} {max_v}')
```


# 2 개구리점프, 실패

```py
T = int(input())

for t in range(1,T+1):
    N , K = map(int,input().split())
    lotus = list(map(int,input().split()))

    def cnt_lts():
        cnt = 0  # 누적합
        k = 0  # 뛴 횟수
        cur = 0  # 현재 위치
        while 0<=cur<N: # 연꽃 범위를 벗어나지 않을 때까지

            if lotus[cur] >= 0: # 만약 현재 위치에 있는 연꽃 값이 +라면


                if k != 0: #현재 위치는 합산 x
                    cnt += lotus[cur]
                    if k > K:
                        return cnt
                cur += lotus[cur]
                k += 1



            elif lotus[cur] < 0 : # 만약 현재 위치에 있는 연꽃이 - 라면
                while lotus[cur] < 0: # 서 있는 곳의 값이 +가 될 때까지
                    if k != 0:  # 현재 위치는 합산 x
                        cnt += lotus[cur]
                    re_cur = lotus[cur] = lotus[cur]# 이후에 한 번에 도약하기 위해 추가될 값
                    cur += lotus[cur]
                    k += 1
                    if k > K :
                        return(cnt)
                    if lotus[cur] >= 0: # 뒤로 갔을 때 값이 + 라면
                        cnt += lotus[cur]
                        cur += lotus[cur]-re_cur # 도약 거리 추가
                        k += 1
                        if k > K:
                            return(cnt)
                        break


                    else: # 뒤로 갔을 때 값이 -라면
                        k += 1
                        cur += lotus[cur]
                        cnt += lotus[cur]
                        if k > K:
                            return(cnt)
                        continue

        return(cnt)

    print(f'{t} {cnt_lts()}')
```


```py

def jump(data):
    result = 0 
    prev = 0 #이전 점프 거리
    pos = 0 # 현재 위치

    for _ in range(M):
        next = data[pos] # 다음 점프할 거리
        if data[pos] > 0 and prev <0: # 만약 이전에 뒤로 점프했다면
            next += -prev
        prev = data[pos] # 현재 점프 거리 저장
        pos += next # 점프한 후 위치
        if pos<0 or pos >= N : #위치를 벗어났으면 종료
            return result
        
        result+= data[pos]
    return result

T = int(input())

for t in range(1,T+1):
    N,M = map(int().split())
    data = list(map(int,input().split()))
    result = jump(data)
    print(f'#{t} {result}')

```

# 3



# Index
- 상속
- 에러와 예외
- EAFP & LBYL

# 1. 상속

## 1) 상속
기존 클래스의 속성과 메서드를 물려받아 새로운 하위 클래스를 생성하는 것
### 상속이 필요한 이유

1. 코드 재사용
   - 상속을 통해 기존 클래스의 속성과 메서드 재사용 가능
   - 새로운 클래스를 작성할 때 기존 클래스의 기능을 그대로 활용 가능, 이로 인해 중복 코드 줄일 수 있음
2. 계층 구조
   - 상속을 통해 클래스간 계층구조 형성 가능
   - 더 구체적인 클래스를 만들 수 있음

3. 유지 보수의 용이성
    - 클래스의 수정이 필요하면 기존 클래스만 수정하면 되서 일관성을 유지하고 수정이 필요한 범위를 최소화 할 수 있음
## 2) 클래스 상속

### 상속 없이 구현하는 경우

 #### 예시
 - 학생/교수 정보를 나타내기 어려움
 - Person이라는 클래스 하나로 학생과 교수가 분류가 되질 않음
 - 학생과 교수 모두 공통적으로 사람임(Person). 여기서 공통점을 두고, 차이점을 가진 하위 클래스를 제작.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def talk(self):
        print(f'반갑습니다. {self.name}입니다.')


class Professor():
    def __init__(self, name, age, department):
        self.name = name
        self.age = age
        self.department = department #이름+나이에 더해 담당하는 과목까지


class Student():
    def __init__(self, name, age, gpa):
        self.name = name
        self.age = age
        self.gpa = gpa #성적까지

'''
Professor()와 Student()는 결국 Person에서 공통적으로 가진 놈들을 상속받고 싶음.

How? 우린 기존 클래스 제작 때 ( ) 안 썼음.
이제 거기에 상위 클래스를 넣으면 됨

class Professor(Person)

class Student(Person)
'''

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def talk(self):
        print(f'반갑습니다. {self.name}입니다.')


class Professor(Person):
    def __init__(self, name, age, department):
        self.name = name
        self.age = age
        self.department = department
    
    # def talk(self):
    #     print(f'잘 부탁드립니다. {self.name}입니다.')


class Student(Person):
    def __init__(self, name, age, gpa):
        self.name = name
        self.age = age
        self.gpa = gpa 


p1 = Professor('박교수', 59, '컴퓨터공학과')

s1 = Student('김학생', 20, 3.5)

print(p1.department) # 컴퓨터공학과

print(s1.gpa) # 2.5

## 그럼 Professor 와 Student에 없는 talk라는 메서드 사용 가능?

p1.talk() #반갑습니다. 박교수입니다
s1.talk() #반갑습니다. 김학생입니다.

# 중복으로 코드를 작성하지 않았다. 그럼에도 쓸 수 있다.


## 그럼 Professor에 자체적으로 talk()라는 메서드를 작성해서 쓸 수 있나?
'''
    def talk(self):
        print(f'잘 부탁드립니다. {self.name}입니다.')
        
        '''
# 덮어쓰기 가능

# 어제 변수 생각해서 talk()라는걸 자체 클래스에서 먼저 찾고, 만약 없다면 부모 클래스에서 사용.
```

모든걸(메서드, 생성자변수, 클래스변수 등) 상속받음


##  super()

부모 클래스 객체를 반환

```python
class Professor(Person):
    def __init__(self, name, age, department):
        self.name = name
        self.age = age
        self.department = department
    # 여기서 Person.변수 사용 가능. 그럼 왜 super()를 쓰냐?
```

이런 이유 때문에

```python
class Person:
    def __init__(self, name, age, number, email):
        self.name = name
        self.age = age
        self.number = number
        self.email = email


# class Student(Person):
#     def __init__(self, name, age, number, email, student_id): 
#         #student_id만 다름. 나머진 다 똑같음
#         #그냥 Person의 생성자를 갖고와서 호출하고 id 관련된거 하나만 작성하면 되지 않을까?

#         self.name = name
#         self.age = age
#         self.number = number
#         self.email = email
#         self.student_id = student_id


class Student(Person):
    def __init__(self, name, age, number, email, student_id): #이건 작성해야함
        super().__init__(name, age, number, email) #여기서 super()는 Person과 같음 == Person.__init__(name, age, number, email)
        #init 호출할 때 갖고올 변수들 쓰고, self는 안 써도 된다.
        self.student_id = student_id                        


'''
그럼 왜 굳이 Person.__init__(name, age, number, email) 이걸 안 쓰고 super()를 쓰냐?

1. 상위 클래스 이름 바뀌면 super 안 쓰면 이름 다 바꿔줘야 함.

2. 다중 상속을 위해. Person 뿐만 아니라 다른 부모 클래스도 있을 수 있음.

- 만약 부모 클래스에 같은 이름의 메서드가 있다면, 어딜 먼저 참조해야할지 교통정리를 super()로 가능
'''
```

## 3) 다중 상속
- 둘 이상의 상위클래스로부터 여러 행동이나 특징을 상속받을 수 있는 것
- 상속받은 모든 클래스의 요소를 활용 가능함
- #### 중복된 속성이나 메서드가 있는 경우 *상속 순서에 의해* 결정됨
   - 먼저 상속받은 애한테서 먼저 찾음

```python
class Person:
    def __init__(self, name):
        self.name = name

    def greeting(self):
        return f'안녕, {self.name}'


class Mom(Person):
    gene = 'XX'

    def swim(self):
        return '엄마가 수영'


class Dad(Person):
    gene = 'XY'

    def walk(self):
        return '아빠가 걷기'

# Person 은 mom dad 둘 한테 상속하고, 이 둘이 FirstChild 둘한테 상속받고 싶음

class FirstChild(Dad, Mom): #다중상속
    def swim(self):
        return '첫째가 수영'
    
    def cry(self):
        return '첫째가 응애'
    

baby1 = FirstChild('김싸피') #생성자가 안 보이면 상위로 타고 올라가야됨. 여기선 Person의 name

print(baby1.cry()) #첫째가 응애

print(baby1.swim()) #첫째가 수영

print(baby1.walk()) #아빠가 걷기

# 그럼 아이의 성별(gene)은?  중복된 속성이나 메서드는 상속 순서에 따라서 달라짐

print(baby1.gene) #XY

# 다중 상속일 땐 먼저 상속받는 애(Dad)한테 먼저 검색함

```

#### <다이아몬드 문제>
- 두 클래스 B, C가 A에서 상속되고, 클래스 D가 B,C 모두에게 상속될 때 발생하는 모호함
- B와 C가 재정의한 메서드가 A에 있고 
정답) DBCA
#### 파이썬에서의 해결 방법


< MRO >

- Method Resolution Order 알고리즘을 통해서
- 깊이 우선으로, + 왼쪽에서 오른쪽으로 먼저 검색
  >중요 : 중복이 없도록 검색



>super() : 
> - 부모 클래스 객체를 반환하는 함수다
>  - +) 다중 상속 시 MRO를 기반으로 현재 클래스가 상속하는 모든 부모 클래스 중 다음에 호출될 메서드를 결정하여 *자동으로* 호출 => 우리가 뭘 먼저 상속받게 할지 고민할 필요 없이 MRO 기반으로 자동으로 찾아줌


## 이거 설명할 때 졸았음
```python
class ParentA:
    def __init__(self):
        self.value_a = 'ParentA'

    def show_value(self):
        print(f'Value from ParentA: {self.value_a}')


class ParentB:
    def __init__(self):
        self.value_b = 'ParentB'

    def show_value(self):
        print(f'Value from ParentB: {self.value_b}')


class Child(ParentA,ParentB):
    def __init__(self):
        super().__init__() #A의 생성자 함수를 갖고 온 것.why? ParentA를 먼저 상속받았으깐
        self.value_c = 'Child'
        ''' 결국 얘는 
        self.value_a = 'ParentA'
        self.value_c = 'Child'
        '''
    def show_value(self):
        super().show_value() #이것도 A를 먼저 찾았는데 있으니깐 A로 끝. 굳이 B까지 안 감.
        print(f'Value from Child : {self.value_c}')

child = Child()
child.show_value()
print(child.value_a)
print(child.value_c)

print(child.value_b) 
''' 오류가 난다! why?
class ParentB:
    def __init__(self):
        self.value_b = 'ParentB'

이건 ParentB 로 인스턴스를 만들었을 때 그 인스턴스가 갖고 있는 것

클래스가 갖고 있는게 아님

'''
```

```python
class A:
    def __init__(self):
        print('A Constructor')


class B(A):
    def __init__(self):
        super().__init__()
        print('B Constructor')


class C(A):
    def __init__(self):
        super().__init__()
        print('C Constructor')


class D(B, C):
    def __init__(self):
        super().__init__()
        print('D Constructor')


obj = D()
# A Constructor
# C Constructor
# B Constructor
# D Constructor

# 그림 그려보면 이해가 쉬움

'''
찾는건 DBCA, 반환은 ACBD. -> 역순
재귀함수의 Stack 개념과 비슷, 쌓이는 순서와 반대로 맨 위에 올라옴

-콜스택
'''

print(D.mro()) 
#[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

#shb 이거 C가 언제 호출된거임??

대전_02반_설무아_전임강사
​@[광주_2반_김선민] 좋은 질문 주셨는데요. 4번 예제에서는 PrarentA의 생성자 함수에 super().__init()__이 없어서 더 이상 생성자 함수를 자동으로 호출하지 않습니다. 그래서 Child()의 생성자 함수와 ParentA의 생성자 함수만을 실행하고 끝이 납니다.

대전_02반_설무아_전임강사
​@[광주_2반_김선민] 05번 예제는 모든 생성자 함수마다 super().__init()__이 있어서 파이썬이 자동으로 호출 가능하고 상속 받고 있는 생성자 함수들을 차례로 호출하게 됩니다.

[광주_2반_김선민]
​@대전_02반_설무아_전임강사 그럼 super() 는 부모 클래스의 인스턴스를 의미하는 게 아니라 정확히는 MRO 상에서 다음으로 탐색할 클래스의 인스턴스를 의미한다고 보는 게 맞나요?


대전_02반_설무아_전임강사
​@[광주_2반_김선민] 네 너무 정확하게 이해하고 계세요 🙂 그런데 편의상 부모 클래스의 인스턴스를 호출한다 정도로 기억해주시고 사용하셔도 좋을 것 같습니다.
```

#### < super의 2가지 사용 사례>

1. 단일 상속 구조


2. 다중 상속 구조


#### < MRO가 필요한 이유>

# 2. 에러와 예외

## 1) 디버깅

### 버그
소프트웨어에서 발생하는 오류 또는 결함. 프로그램의 예상된 동작과 실제 동작 사이의 불일치.

### 디버깅
버그를 찾아내고 수정하는 과정. 츠로그램의 오작동 원인을 식별하여 수정하는 작업

### < 디버깅 방법>

1. print 함수 활용
2. 개발 환경 등에서 제공하는 기능 활용
3. Python Tutor
4. 뇌버깅

## 2) 에러
프로그램 실행 중에 발생하는 예외상황. 두가지 중

1. 문법에러 Syntax Error
파이썬에서 실제로 허용하는 문법을 사용하지 않았을 때.

2. 예외 Exception
   문법적인 걸 제외한 모든 에러. 얘가 제일 많음
   그럼 예외 처리를 어떻게 해야하나?

### 1) 문법 에러 예시
- Invalid Syntax (문법오류)

- 

- EOL (End of Line) 
- EOF (End of File)

## 3) 예외

문법 에러 제외 나머지. 

### 내장 예외 
예외 상황을 나타내는 예외 클래스들 => 클래스로 만들어짐
 > 파이썬에서 이미 정의되어 있으며, 특정 예외 상황에 대한 처리를 위해 사용

1) ZeroDivisionError : 0으로 나누려 할 때
2) NameError : 지역 또는 전역 공간에서 이름을 찾을 수 없을 때
3) Type error
    - 타입 불일치
    - 인자 누락 ex) sum() 위치 인자 아무것도 안 넣었을 때
    - 인자 초과 : 받을 수 있는 인자의 갯수보다 더 많이 넣었을 때
    - 인자 타입 불일치 : 인자에 필요한 타입과 다른 타입의 인자를 넣을 때
    - ValueError : 연산이나 함수에 문제가 없지만, 부적절한 값을 가진 인자를 받았고, 사황이 IndexError처럼 더 구체적인 예외로 설명되지 않는 경우 ex) int('1.5') or range(3).index(6)
    - IndexError : 시퀀스 인덱스가 범위를 벗어날 때 발생. ex) out of range : 반복에서 많이 발생
    - KeyError : 주로 딕셔너리. 찾는 키가 없을 때. 근데 .get() 은 에러 안 남.
    - ModuleNotFoundError : import 하려는 모듈이 존재하지 않을 때
    - ImportError : 모듈은 있는데 그 안의 원하는 무언가가 없을 때
    - KeyboardInterrupt : 터미널에서 무한 반복 등 무언가 잘못됐을 때 우리가 억지로 멈추면 멈추면서 이 에러를 출력
    - IndentationError : 들여쓰기가 잘못되었을 때 


## 4) 예외 처리
 ### try와 except
 파이썬에서 try문과 except 절을 사용하여 예외 처리
 < try-except 구조 >
- try 블록 안에는 예외가 발생할 수 있는 코드를 작성
- except 블록 안에는 예외가 발생했을 때 처리할 코드를 작성
- try에서 예외가 발생하면 try 블록을 빠져나와 except문 안의 블럭을 실행


```python
'''
result = 10 / 0 #ZeroDivisionError
print('0으로 나눌 수 없습니다') #이 상태론 print 되지 않음
'''

try:
    result = 10/0

except ZeroDivisionError:
    print('0으로 나눌 수 없습니다.')

# 이 except는 ZeroDivisionError밖에 못 봄. 그럼 다른 error는?

name = 'hello
try:
    print(name)

except ZeroDivisionError:
    print('0으로 나눌 수 없습니다.')
#이러면 그냥 실행 안 됨. 

name = 'hello
try:
    print(name)

except : #이런 식으로 가능. 그러나 추천은 안 함.
    print('0으로 나눌 수 없습니다.')
```
```python
try:
    num  int(input('숫자 입력: '))

except ValueError:
    print('숫자가 아닙니다.')
```

### < 복수 예외처리 >

```python
num = int(input('100으로 나눌 값을 입력하시오 : ')) 
print(100/num)
#zerodivision과 typeerror 의심

try:
    num - int(input('100으로 나눌 값을 입력하시오 : '))
    print(100/num)
except ValueError:
    print('숫자를 넣어줘')
except ZeroDivisionError:
    print('0으로 나누기가 될 것 같아')
# 이것만 있으면 이 두 에러만 처리 가능. 나머지는 코드 실행이 안됨.

#그래서 else를 만들어둠

except:
    print('알 수 없는 에러가 발생했음')

'''
except (ValueError,ZeroDivisionError):
    (공통 코드)
이런 식으로도 넣을 수 있음
'''
```

```python
try:
    num - int(input('100으로 나눌 값을 입력하시오 : '))
    print(100/num)
except BaseException: # 모든 에러 총집합
    print('숫자를 넣어줘')
except ZeroDivisionError:
    print('0으로 나누기가 될 것 같아')

'''
이러면 input에 0 넣어도 '0으로 나누기가 될 것 같아' 되어버림.

why? 굳이 아래까지 갈 수가 없음.
'''
```

# 2.5. 참고

## 1) as 키워드
 as 를 통해 error 이름으로 바꿀 수 있음

 졸았으니 예시 확인

# 3. EAFP & LBYL
예외철;와 값 검사에 대한 두 가지 방식
## 1) EAFP 
: 허락보다 용서를 구하는게 더 쉽다 => 일단 실행하고 예외처리를 중심으로 코드를 작성하는 접근 방식

ex) try-except

## 2) LBYL 
:코드를 실행하기 전에 한 번 확인해서 미리 예상
돌다리도 두드려보고 건너기
ex) if-else

#### 결국 둘 다 같은 코드로 만들 수 있다.

```python
#딕셔너리에서 키를 조회할 때 키가 없다는 상황을 2개로 만들어본다.

my_dict = {}

#1) try - except

try:
    result = my_dict['a'] #일단 때려박고 시작
    print(result)
except:
    print('key가 존재하지 않습니다.')

#2) if-else

if 'a' not in my_dict: #한 번 확인하고 시작
    result = my_dict['a']
    print(result)    
else:
    print('key가 존재하지 않습니다.')


'''
결과는 같지만 코드의 스타일은 전혀 다르다.

우린 문제 해결을 거의 해본적이 없어서 1위주로 했음

2는 문제 해결을 위한 것

'''
```

#### <접근 방식 비교>

- EAFP : 예외가 발생한 후에 예외처리.

  - when? 우리가 에러를 예상하기 힘들 때


- LBYL : 실행하기 전에 조건을 검사, 예외 상황을 미리 검사하고 예외 상황을 피하는 방식

  - when?  예외상황을 미리 방지하고 싶을 때 . 
  - 코드가 더 길고 복잡해질 수 있다.

 =============================================================================================

# OFF-Line

## 1. 상속

### 상속의 장점

: 코드 재사용, 유지보수

when? 부모 클래스에 공통된 특징이나 동작을 정의 -> 자식 클래스에는 부모의 특징을 이용해서 다양한 변화

### 상속의 종류

1) 클래스 상속
   
   how? 
   ```python
   자식클래스명(부모클래스명):
   ```
2) 메서드 상속
   
   how? 
   ```python
   super()
   ```

#### <다중상속 실습>
```python
#<다중상속>

class Car:
    def __init__(self,model):
        self.model = model


class Hyundai(Car):
    color = 'white'

    def speed(self):
        return "30km/h"

class Kia(Car):
    color = "black"
    
    def engine(self):
        return '1.6 turbo'

class CarDrive(Hyundai,Kia):
    def speed(self):
        return '50km/h'
    
    def power(self):
        return '1.999cc'
    
car = CarDrive('Sonata')
print(car.speed()) #메서드 호출  #50km/h

print(car.color) #클래스 변수 접근 #white


'''
메서드 호출: 가장 마지막에 호출된 애가 나온다.

클래스 변수 접근: 먼저 상속된 애(Hyundai)
'''
```

메서드 : MRO에 따른다. 따라서 가장 마지막에 호출된 애가 나온다. - *메서드 오버라이드*

클래스 변수 : 클래스가 정의된 순간에 값이 정해져서 유지된다. -> 제일 먼저 상속된 애로 굳어진다. 

### < PDF 다이아몬드 다중상속 문제 설명 > 

18p를 봐야 함

```python
class A:
    def __init__(self):
        print('A Constructor')


class B(A):
    def __init__(self):
        super().__init__()  #A를 한 번 탐색했기 때문에 재탐색하지 않는다.
        print('B Constructor') # B Constructor


class C(A):
    def __init__(self):
        super().__init__() # A Constructer 그 다음
        print('C Constructor') # C Constructor 그 다음 C 탐색 끝났으니깐 B로


class D(B, C):
    def __init__(self):
        super().__init__() # B부터? C부터? C로 이후 B로
        # A Constructer -> C Constructor -> B Constructor -> D Constructor
        print('D Constructor')


obj = D()
# A Constructor
# C Constructor
# B Constructor
# D Constructor

print(D.mro())
#[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]

# 여기선 DBCA라 우리가 DCAB라는걸 확실히 알 수 가 없음
```

이런 상속을 *다이아몬드 상속* 이라 한다.

init '메서드'를 갖고 옴(super( )) => MRO 알고리즘 : 1) 왼쪽에서 오른쪽, 2) 깊이우선(반대로 뒤집음), 3) 같은걸 2번 검색하지 않음

깊이 우선 : D -> B -> A -> C  , 왼쪽 다 돌고 오른쪽 도는데...

근데 깊이 우선은 그림을 180도 돌려서 : D -> C -> A -> B

왜 깊이 우선? 만드는걸 D()를 만들어서...
> obj = D()


<추가>
```python
# 이건 어떻게 나올까?

class A:
    def __init__(self):
        print('A Constructor')


class B(A):
    def __init__(self):
        super().__init__() 
        print('B Constructor')


class C(A):
    def __init__(self):
        super().__init__()
        print('C Constructor')


class D(C, B):
    def __init__(self):
        super().__init__()
    
        print('D Constructor')


obj = D()
```

## 2. 버그

### 디버깅 : 버그를 해결하는 과정

오류 뿐만이 아니라 내가 원하는 결과가 아닌 것도 버그, 이걸 수정하는 것도 디버깅

에러 
1) 문법 에러 : 고치기 너무 쉽다.
2) 예외 : 알고리즘 문제를 풀면서 발생하는 에러의 대부분

### 대표적인 예외 케이스

>1. Name Error : 변수를 초기화 안 했거나, 지역 변수의 위치가 잘못되었거나

>2. Type Error


```python
def calculate_sum(a,b):
    return a+b

numbers =[1,2,3,4,5]
result = 0

#만약 result = [] 로 한다면? TypeError
for i in range(len(numbers)):
    
    result = calculate_sum(result,numbers[i]) # i = 0 일 때 result가 할당이 안 되어있다.
#NameError , result를 초기화해야한다. 
print(result)
```

>3. Index Error : 인덱스의 범위가 벗어났을 경우. 가장 골치가 아픈 에러

```python
def calculate_sum(a,b):
    return a+b

numbers =[1,2,3,4,5]
result = 0

for i in range(len(numbers)):
    
    result = calculate_sum(result,numbers[i+1]) # i = 5 일 때 number[6]이 되어버린다. 
print(result)
```
우회하려면?
```python
def my_index(arr,index):
    try:
        result =arr[index]
    except IndexError:
        result = None

    return result


my_list = [1,2,3,4,5]
index_1 = int(input())
element = my_index(my_list,index_1)
print(element)
```
### 물론 이런다고 테스트케이스 통과가 되지는 않는다.

## EAFP , LBYL

일단 코드를 실행하고 본다. 그 후 에러 처리 -> EAFP

내가 코드를 실행하기 전에 에러를 예상하고 대비한다 -> LBYL


# 실습


## ws_8_1 
< 클래스 변수 접근과 상속 >

```python
# 아래 클래스를 수정하시오.
class Animal:
    num_of_animal = 0
    


class Dog(Animal):
    def __init__(same):
        # print(same.num_of_animal)
        # same.num_of_animal += 1 #0->1 #Dog의 속성에 새로운 num_of animal이 생긴거임. 클래스 변수엔 영향을 주지 않음
        Animal.num_of_animal += 1
        #init 매서드에서 클래스 변수에 접근하려면 클래스명.클래스변수명 으로 접근해야한다. (init 매서드 특징)
        # print(same.num_of_animal)
         


class Cat(Animal):
    def __init__(same):
        # print(same.num_of_animal)
        Animal.num_of_animal += 1
        # print(same.num_of_animal)
        


class Pet(Dog,Cat):
    @classmethod
    def access_num_of_animal(cls):
        return f'동물의 수는 {cls.num_of_animal}마리 입니다.'
    


dog = Dog()
print(Pet.access_num_of_animal())
cat = Cat()
print(Pet.access_num_of_animal())

# 동물의 수는 1마리 입니다.
# 동물의 수는 2마리 입니다.
```

>아니면 Animal 클래스에서 건들 수도 있다.

```python
# 아래 클래스를 수정하시오.
class Animal:
    num_of_animal = 0
    def __init__(same):
        Animal.num_of_animal += 1
    
class Dog(Animal):
    pass

class Cat(Animal):
    pass

class Pet(Dog,Cat):
    @classmethod
    def access_num_of_animal(cls):
        return f'동물의 수는 {cls.num_of_animal}마리 입니다.'
    


dog = Dog()
print(Pet.access_num_of_animal())
cat = Cat()
print(Pet.access_num_of_animal())

# 동물의 수는 1마리 입니다.
# 동물의 수는 2마리 입니다.
```
## hw_8_4
< try-except 활용과 클래스에서 전역, 로컬 변수 >

```python
class UserInfo:
    def __init__(self):
        self.user_data = {}

    def get_user_info(self):
        try :
            self.name = input('이름을 입력하세요 : ')
            self.age = int(input('나이를 입력하세요 : '))
            #메서드는 기존 LEGB 룰의 지역변수, 전역변수와 다르게 self에 제대로 할당이 된다.
            self.user_data.setdefault('이름',self.name)
            self.user_data.setdefault('나이',self.age)
            #user_data 딕셔너리에 데이터 삽입
            
        except ValueError:
            print('나이는 숫자로 입력해야 합니다.')
            
    def display_user_info(self):
        try:
            print(f'이름 : {self.name}\n나이 : {self.age}')

        except AttributeError:
            print('사용자 정보가 입력되지 않았습니다.')

    


user = UserInfo()
user.get_user_info()
user.display_user_info()

```
```python
# 이미 할당되어 있는걸 쓰면 상관 없어질거 같다.
class UserInfo:
    def __init__(self):
        self.user_data = {}

    def get_user_info(self):
        try :
            self.name = input('이름을 입력하세요 : ')
            self.age = int(input('나이를 입력하세요 : '))
            #메서드는 기존 LEGB 룰의 지역변수, 전역변수와 다르게 self에 제대로 할당이 된다.
            self.user_data['이름'] = self.name 
            self.user_data['나이'] = self.age
            #setdefault 쓰면 덮어쓰기 당한다!
            
        except ValueError:
            print('나이는 숫자로 입력해야 합니다.')
            
    def display_user_info(self):
            if self.user_data:#user_data에 뭐라도 들어가있으면 True
                for key, value in self.user_data.items():
                    print(f'{key} : {value}')
            else:
                print('사용자 정보가 입력되지 않았습니다.')

```

# 월말평가

총 11문제
파이썬 8일 ---> 모두 복습해야 한다.
중요하지 않은 내용은 안 나온다.
자잘한건 제외

try, except까지 

재귀함수 1문제 나온다. 9번

problem.py ..... problem11.py 제출



1. 함수를 만드세요.(내장함수는 사용시 감점, len함수 포함)
2. 10번, 11번 쉬운 알고리즘 문제 - 2차원 리스트 (10번, 11번), 방향배열
3. 재귀함수 9번
4. len,max,min,sum 사용 금지. 메서드 포함
//
// Created by user on 24. 4. 20.
//
#include <stdio.h>


int Add(int left, int right){
    return left+right;
}

// 구조체 struct
// 사용자 정의 자료형
typedef struct _tagMyST // _tagMyST가 실제 이름
{
    int a; // 이건 변수가 아니다. 그냥 파트의 이름임
    float f;
    // int 와 float을 묶어서 하나의 자료형을 만든 것

}MYST; // MYST가 자료형의 별명

typedef struct _tagBig
{
    MYST k;
    int i;
    char c;

}BIG;

typedef int INT; // 이제 내가 INT a; 라고 해도 프로그램은 int a;와 똑같이 반응한다.

int main()
{

    // 구조체
    MYST t; // 8바이트, int하나 , float 하나
    MYST o = {1,3.14f}; //  이런 식으로 초기롸 가능
    int iSize = sizeof(MYST); //
//    printf("%d", iSize); // 8
    t.a = 10;
    t.f = 1.2312f;

    // 구조체 안에 구조체가 들어갈 수도 있다




//    int i = 0;
    //i : 변수
    //int : 자료형
    // 정수형 : char(1),short(2),int(4),long(4),long long(8)
    // 실수형 : float(4),double(8)


    // msb(맨 앞의 비트)로 원래 부호 확인
    // 근데 음수 a 는 a와 더해서 0이 되는 수
    // 그래서 숫자 싹 다 반대로 만들고 1 더한게 음수 값이 됨(2의 보수법)
    // 1111/1111의 음수 값은 0000/0001이 된다.
    // 더하면 승수 올라가서 0000/0000이 된다.

    char data = 255; // 데이터가 양수, 음수 둘 다 인식
    // 모든 데이터가 1로 채워짐 -> -1로 인식
    // 결국 데이터 형의 해석 여부에 따라 같은 데이터도 다르게 인식하게 된다. -> 관점에 따른 해석이 다르다.


    unsigned char data2 = 255; // 데이터가 양수만 인식

    data2 = -1;
    // data2는 1111/1111 (-1)로 비트 값이 들어간다
    // 근데 얘는 양수만 받는거라 최대값인 255로 인식한다.

    printf("%d",data);
    printf("\n%d",data2);


    // int(4바이트)와 long(4바이트)의 차이???
    //원래 int는 4바이트로 사용되려고 한 게 아니었는데 설계가 바뀜

    // 2. 실수형

    // 실수형 또한 제한된 메모리를 다뤄야 하는데, 방식이 전혀 다름
    // 0~1 사이의 실수 값은 무한 개임
    // 그래서 부동 소수점을 사용함

    // ## 정수와 실수는 메모리의 표현 방식 자체가 다르다 라는 것이 가장 중요
    // 4는 정수로는 0000/0100이지만, 실수론 전혀 다르다
    // 부동 소수점 때문에 실수의 정밀도도 잘 생각해봐야한다.

    // 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현 방식의 피 연산자가 연산될 경우 '명시적으로' 변환하자.


    int a = 4+4.0; // 4.0을 4로 다시 형변환했다. // 이렇게 하지 말고
    float f = 10.2415f + (float)(20); // 이런 식으로 명시적으로 사용

    float b = 4+4.0;
    printf("\n%d",a); // 4
    printf("\n%f",a); // 0.000000
    printf("\n%d",b); // 0
    printf("\n%f",b); // 8.000000

    // 3. 연산자
    // 산술 연산자
        // +.-,*,/,%(모듈러스, 나머지 연산자)
        // ++ , --
        // 이 연산자들끼리 우선 순위가 다르다.
    // 대입 연산자
    // 주의
        // 실수끼리는 나머지 연산이 불가능. 둘 중 하나라도 안 된다. %는 피연산자끼리만


    float data3 = 10+10;

    data3 = (int)(10./3.);

    printf("\n%f",data3);



    // 증감 연산자
        // ++.--는 *한 단계* 증가, 감소
        //앞에 붙이냐 뒤에 붙이냐에 따라서도 의미가 달라짐(전치,후치) -> 연산자 우선 순위가 달라짐
            //++data 전위(전치) -> 모든 연산자 우선 순위 중
            // data++ 후위(후치) -> 모든 연산자 우선 순위 중 가장 나중, 대입 연산자 보다도 늦음

    data = 0;
    a = 10;
    data = a++;
    // data에 a를 넣고 a를 증가 -> data에 있는 값은 10
    printf("\n%d",data); //10
    printf("\n%d",a); // 11

    data = ++a;
    printf("\n%d",data); // 12
    printf("\n%d",a); // 12
    // a를 증가하고 data에 넣음 -> 데이터에 있는 값은 11


    // 만약 언제 넣어도 상관 없는 경우라면 그냥 전위로 써라. 그게 더 좋은 습관임


    // 4. 논리 연산자
    // !(역), &&(곱), ||(합)
    // 참(true), 거짓(false)


    // 6. 비트 연산자
    // 1) 쉬프트 << , >> -> 비트를 방향대로 한칸 씩 민다

    unsigned char byte = 1; // 0000 0001

    byte <<= 1; // 0000 0010 -> 2배 증가.

    unsigned char byte2 = 10; // 0000 1010

    byte2 <<= 1; // 0001 0101 -> 20 , 2배 증가.

    byte <<= 3; // 8배 증가

    byte >>= 1; // 1/2배 -> 나머지가 생기냐? 아니. 비트 동작을 생각해라
    // 나머지가 있다-> 끝자리가 1이다. => 이게 없어지는거 => 2로 나눈 몫만 생긴다
    // 결국 byte>>n은 2^n으로 나눈 몫

    // 2) 비트 곱(&),합(|),xor(^),반전(~)
    // 2-1) 비트곱 -> 각 자리 비트끼리 비교. 둘 다 1이면 1, 둘 중 하나만 0이어도 0

    // 2-2) 비트합 -> 둘 중 하나만 1이라도 1
    // 2-3) 반전 -> 모든 자리를 반전
    // 2-4) xor -> 같으면 0, 다르면 1 -> 그래서 반전한거끼리 xor 하면 11111111 나옴

    // 7, 전처리기 define -> 내가 지정한 구문을 치환할 수 있음
    #define Hungry 1 // 이제부터 Hungry는 1로 받아들여진다.
    unsigned int iStatus = Hungry;
    // 왜 쓰냐?
    // 1) 가독성. 화상 데미지 26, 빙결 데미지 52 이런 것들 다 외워야 되냐? x  가독성 올라간다.
    // 2) 유지보수 .만약 Hungry가 바뀐다면? define 부분만 바꾸면 됨. -> 유지보수 측면에서 훨씬 낫다.

    // 7.5 전처리기 + 비트연산자
    // 현재 iStatus는 32비트(int)
    // 총 몇 가지 상태를 해당 비트 안에 조합할 수 있을까? 32가지 상태(한 비트당 하나의 상태)
    #define Thirsty 2 // 2^1 //0x2 //16비트
    #define Cold 4 // 2^2 //0x4
    #define Hot 8//0x8
    #define Tired 16//0x10
    #define Poison 0x20
    #define Poison1 0x40
    #define Poison2 0x80
    #define Poison3 0x100
    #define Poison4 0x200
    #define Poison5 0x400
    #define Poison6 0x800

    iStatus = 0;
    iStatus |= Hungry;
    iStatus |= Thirsty;

//    if(iStatus & Thirsty)//둘의 자릿수가 다 1이어야 1, 여긴 두 번째 자리가 1이어야 함
//    {
//
//    }
//     특정 자리 비트 제거
//     iStatus &= ~Thirsty;

    // 8. 변수
    // 1) 지역변수
    // 우리가 작성하는 변수는 모두 main() 안에 들어가있다. 이걸 함수라고 부름.

    // 2) 전역변수
    // 함수 바깥에 선언하는 변수

    // 함수? 기능. 특정 기능을 기준으로 나누는 것. 필요 기능에 따라 나눠 놓는걸 '모듈화' 라고 한다.


    int sumv = Add(10,20);
    printf("\n%d",sumv);


    // 3) 정적변수
    // 4) 외부변수
    //

    //9, 반복문

    // 특정 조건을 만족하기까지 지속적으로 반복
    // for문과 while문

    // 1) for()

//    for( /*반복자 초기화*/; /*반복자 조건 체크*/; /*반복자 변경*/)
//    {
//
////    }
//
//    printf("\nOUTPUT TEST START\n");
//
//    for(int i = 0;i<10;++i)
//    {
//        if(i==2 | i == 3){
//            printf("it is continued\n");
//            continue;
//        }
//        printf("OUTPUT TEST\n");
//
//
//    }
//
//    // 2) while()
//    int i = 0 ;
//    while(/*조건체크*/i<2)
//    {
//        printf("output test\n");
//        ++i;
//
//    }


    // 배열

    int iArray[10] = {};

    iArray[4] = 10;
//    iArray[10] = 0;  // 배열 이상이니깐 오류가 난다. 근데 항상 난다는 보장이 없다.
    // 배열은 메모리가 연속적.
    // iArray[10]이라는 메모리 주소에 이미 다른 변수가 할당되어 있었고, 그 변수를 건드려서 값을 바꾼 것 일수도 있다.

    // 구조체
    // 사용자 정의 자료형(데이터 타입)
    // 6m 51s
    //https://youtu.be/Nrtg_YSqwu4?si=DS4KZDIKkxsGdTXa

    return 0;
}
//
// Created by user on 24. 4. 20.
//
#include <stdio.h>

int main()
{
//    int i = 0;
    //i : 변수
    //int : 자료형
    // 정수형 : char(1),short(2),int(4),long(4),long long(8)
    // 실수형 : float(4),double(8)


    // msb(맨 앞의 비트)로 원래 부호 확인
    // 근데 음수 a 는 a와 더해서 0이 되는 수
    // 그래서 숫자 싹 다 반대로 만들고 1 더한게 음수 값이 됨(2의 보수법)
    // 1111/1111의 음수 값은 0000/0001이 된다.
    // 더하면 승수 올라가서 0000/0000이 된다.

    char data = 255; // 데이터가 양수, 음수 둘 다 인식
    // 모든 데이터가 1로 채워짐 -> -1로 인식
    // 결국 데이터 형의 해석 여부에 따라 같은 데이터도 다르게 인식하게 된다. -> 관점에 따른 해석이 다르다.


    unsigned char data2 = 255; // 데이터가 양수만 인식

    data2 = -1;
    // data2는 1111/1111 (-1)로 비트 값이 들어간다
    // 근데 얘는 양수만 받는거라 최대값인 255로 인식한다.

    printf("%d",data);
    printf("\n%d",data2);


    // int(4바이트)와 long(4바이트)의 차이???
    //원래 int는 4바이트로 사용되려고 한 게 아니었는데 설계가 바뀜

    // 2. 실수형

    // 실수형 또한 제한된 메모리를 다뤄야 하는데, 방식이 전혀 다름
    // 0~1 사이의 실수 값은 무한 개임
    // 그래서 부동 소수점을 사용함

    // ## 정수와 실수는 메모리의 표현 방식 자체가 다르다 라는 것이 가장 중요
    // 4는 정수로는 0000/0100이지만, 실수론 전혀 다르다
    // 부동 소수점 때문에 실수의 정밀도도 잘 생각해봐야한다.

    // 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현 방식의 피 연산자가 연산될 경우 '명시적으로' 변환하자.


    int a = 4+4.0; // 4.0을 4로 다시 형변환했다. // 이렇게 하지 말고
    float f = 10.2415f + (float)(20); // 이런 식으로 명시적으로 사용

    float b = 4+4.0;
    printf("\n%d",a); // 4
    printf("\n%f",a); // 0.000000
    printf("\n%d",b); // 0
    printf("\n%f",b); // 8.000000

    // 3. 연산자
    // 산술 연산자
        // +.-,*,/,%(모듈러스, 나머지 연산자)
        // ++ , --
        // 이 연산자들끼리 우선 순위가 다르다.
    // 대입 연산자
    // 주의
        // 실수끼리는 나머지 연산이 불가능. 둘 중 하나라도 안 된다. %는 피연산자끼리만


    float data3 = 10+10;

    data3 = (int)(10./3.);

    printf("\n%f",data3);



    // 증감 연산자
        // ++.--는 *한 단계* 증가, 감소
        //앞에 붙이냐 뒤에 붙이냐에 따라서도 의미가 달라짐(전치,후치) -> 연산자 우선 순위가 달라짐
            //++data 전위(전치) -> 모든 연산자 우선 순위 중
            // data++ 후위(후치) -> 모든 연산자 우선 순위 중 가장 나중, 대입 연산자 보다도 늦음

    data = 0;
    a = 10;
    data = a++;
    // data에 a를 넣고 a를 증가 -> data에 있는 값은 10
    printf("\n%d",data); //10
    printf("\n%d",a); // 11

    data = ++a;
    printf("\n%d",data); // 12
    printf("\n%d",a); // 12
    // a를 증가하고 data에 넣음 -> 데이터에 있는 값은 11


    // 만약 언제 넣어도 상관 없는 경우라면 그냥 전위로 써라. 그게 더 좋은 습관임


    // 4. 논리 연산자
    // !(역), &&(곱), ||(합)
    // 참(true), 거짓(false)


    // 6. 비트 연산자
    // 1) 쉬프트 << , >> -> 비트를 방향대로 한칸 씩 민다

    unsigned char byte = 1; // 0000 0001

    byte <<= 1; // 0000 0010 -> 2배 증가.

    unsigned char byte2 = 10; // 0000 1010

    byte2 <<= 1; // 0001 0101 -> 20 , 2배 증가.

    byte <<= 3; // 8배 증가

    byte >>= 1; // 1/2배 -> 나머지가 생기냐? 아니. 비트 동작을 생각해라
    // 나머지가 있다-> 끝자리가 1이다. => 이게 없어지는거 => 2로 나눈 몫만 생긴다
    // 결국 byte>>n은 2^n으로 나눈 몫

    // 2) 비트 곱(&),합(|),xor(^),반전(~)
    // 2-1) 비트곱 -> 각 자리 비트끼리 비교. 둘 다 1이면 1, 둘 중 하나만 0이어도 0

    // 2-2) 비트합 -> 둘 중 하나만 1이라도 1
    // 2-3) 반전 -> 모든 자리를 반전
    // 2-4) xor -> 같으면 0, 다르면 1 -> 그래서 반전한거끼리 xor 하면 11111111 나옴

       // 7, 전처리기 define 18m
    return 0;
}
//
// Created by user on 24. 4. 29.
//

#include <stdio.h>


// 포인터
int main(){

    // 포인터 변수
    // 포인터 : 주소를 가리키는 변수
    // 포인터 변수는 포인터 기능을 하는 변수

    int* pInt = nullptr; // nullptr 는 0과 같음. 아무 주소도 가리키지 않는다는 뜻
    //int*? 별이 붙는 순간, 포인터 변수로 바뀐다. 따라서 *int 변수를 가리키는* 변수가 된다.

    int i = 100;
    int* poInt = &i; // 이제 i의 주소를 저장하는 변수가 됐다.
    // cpp의 가장 큰 능력은 메모리를 직접적으로 변수로 사용할 수 있다는 것


    // 주소로 접근
    *poInt = 110;//*poInt : 참조 -> i로 가는 것
    printf("%d",i); // 110


    // 주소의 단위
    // 바이트 단위 -> 그 사이 비트 단위로는 주소를 쪼갤 수 없다.

    // 그럼 왜 int형만 담을 수 있도록 포인트 변수를 지정할까? (특정 데이터 타입만)
    // 시작 지점을 체크하고, 4바이트만 관리하려고
    // '나는 내가 가리키는 주소를 모두 int라 받아들이고 메모리에 할당된 비트들을 계산해서 할당해줄거다'
    // 그럼 4바이트의 다른 애들을 집어넣어도 상관 없을까?
    // 아님
    // 정수 자료형과 실수 자료형은 애초에 비트 계산 방법 자체가 다름
    // 이건 자료형 배웠을 때 다시 생각해라.

    // 그럼 그런 애를 참조해서 강제로 int화 해버리면 상당히 곤란해짐
    // 애초에 포인터 변수를 할당할 때 앞으로 어떻게 해당 메모리를 해석할 건지도 확인한다.

//    float f = 3.f;
//    int* poiInt = (int*)&f;

    // 정리
    // (자료형) + (*변수명)
    // 자료형 : 해당 포인터에게 전달된 주소를 '해석하는' 단위

    // 그럼 포인터 변수의 크기는 몇일까?
    // int*니깐 int의 크기? x 얜 단지 해석의 방법을 결정해놓은것!


    // 포인터 변수의 크기는 x64인지 x86인지에 따라 플랫폼에 따라 달라진다

    // 32bit 운영체제 -> 4바이트 -> 데이터를 4바이트 단위로 처리한다.
    // 64bit 운영체제 -> 한 번에 8바이트 처리 가능 => 주소값도 8바이트 단위로 끊긴다 -> *포인터 변수도 8바이트*
    //32bit 운영체제에서 명령어 한번에 만들어낼수 있는 주소수? 0~2^32-1 -> 42억번지정도 가능 -> 대략 4기가바이트 => 그래서 램이 4기가 바이트 이상은 의미가 없음
    // 64bit는 42억*42억 바이트 만큼

    // 현재 포인터 변수의 크기는 8 바이트다.
    int iSize = sizeof(pInt); //8바이트

    // 현재 포인터 변수는 정수형 표현방식

    int k = 0;
    pInt = &k; //만약 k의 시작 번지수가 100이라면 끝 번지수는? 104, int(4바이트)니깐

    pInt+=1; // 만약 포인터 변수에 1을 더하면? 104가 된다 why?
    // 주소 연산은 일반 정수형 연산을 따르지 않는다.
    // pInt는 일반 정수가 아니라 주소를 가리키는 것, 주소를 보고 -> 다음 주소를 'int'로 생각해라
    // 데이터가 왜곡되지 않으려면 다음 주소는 104번지로 가는게 맞다. 100~103이 해당 정수였는데 101~104를 바라보게 하면 어떤 지랄이 날지 모름.
    // 그래서 포인터변수의 증감의 단위는 정의될 때의 해석 단위(int,char,short,float...)에 따라 다르다.


    // 정리
    // pInt는 int*변수이기 때문에, 가리키는 곳을 int로 해석한다.
    // 따라서 주소값을 1 증가하는 의미는 다음 int위치로 접근하기 위해서 sizeof(int)단위로 증가하게 된다.

    //-----------------------------------------------------------------------------
    // '배열을 정확하게 이해하려면 포인터에 대한 개념이 필요하다'
    // '왜?'

    // 포인터와 배열

    // 배열의 특징
    // 1. 10묶음의 메모리 공간이 연속적이다!
    // 2. 배열의 이름(iArr)은 배열의 시작 주소이다. -> NEW!

    int iArr[10] = {};

    // iArr은 해당 배열의 시작 주소임
//    iArr +1; // -> 포인터 증감과 똑같다. 얘 지금 4바이트 움직인거임

    //참조-> 해당 값으로 가는 것. 결국 메모리로 접근해서 해당 메모리들에 저장된 해당 값(int단위, 4바이트)만큼을 접근해서 해석하는 것
    *(iArr+1)=10; // iArr로부터 1칸 띈 공간에 접근해라 -> 이 1칸의 단위가 int, 즉 4바이트
    // 그러니깐 위의 의미는, iArr+1부터 4바이트까지 접근해서, 4바이트만큼 해석하는 것
    // 이러면 배열의 2번째 값이 10으로 지정된다.

    // 첫 번째 칸에 10을 넣고 싶었으면?
    *(iArr+0) = 10; // => 이래서 배열의 첫 번째 단위가 0이었던 거다!! iArr[0] = 10;

    return 0;
}
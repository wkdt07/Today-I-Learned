//
// Created by user on 24. 4. 29.
//

#include <stdio.h>


void Test(int a)
{

    a = 500;
}

void Test2(int* a){
    *a = 500;
}
// 포인터
int main(){

    // 포인터 변수
    // 포인터 : 주소를 가리키는 변수
    // 포인터 변수는 포인터 기능을 하는 변수

    int* pInt = nullptr; // nullptr 는 0과 같음. 아무 주소도 가리키지 않는다는 뜻
    //int*? 별이 붙는 순간, 포인터 변수로 바뀐다. 따라서 *int 변수를 가리키는* 변수가 된다.

    int i = 100;
    int* poInt = &i; // 이제 i의 주소를 저장하는 변수가 됐다.
    // cpp의 가장 큰 능력은 메모리를 직접적으로 변수로 사용할 수 있다는 것


    // 주소로 접근
    *poInt = 110;//*poInt : 참조 -> i로 가는 것
    printf("%d",i); // 110


    // 주소의 단위
    // 바이트 단위 -> 그 사이 비트 단위로는 주소를 쪼갤 수 없다.

    // 그럼 왜 int형만 담을 수 있도록 포인트 변수를 지정할까? (특정 데이터 타입만)
    // 시작 지점을 체크하고, 4바이트만 관리하려고
    // '나는 내가 가리키는 주소를 모두 int라 받아들이고 메모리에 할당된 비트들을 계산해서 할당해줄거다'
    // 그럼 4바이트의 다른 애들을 집어넣어도 상관 없을까?
    // 아님
    // 정수 자료형과 실수 자료형은 애초에 비트 계산 방법 자체가 다름
    // 이건 자료형 배웠을 때 다시 생각해라.

    // 그럼 그런 애를 참조해서 강제로 int화 해버리면 상당히 곤란해짐
    // 애초에 포인터 변수를 할당할 때 앞으로 어떻게 해당 메모리를 해석할 건지도 확인한다.

//    float f = 3.f;
//    int* poiInt = (int*)&f;

    // 정리
    // (자료형) + (*변수명)
    // 자료형 : 해당 포인터에게 전달된 주소를 '해석하는' 단위

    // 그럼 포인터 변수의 크기는 몇일까?
    // int*니깐 int의 크기? x 얜 단지 해석의 방법을 결정해놓은것!


    // 포인터 변수의 크기는 x64인지 x86인지에 따라 플랫폼에 따라 달라진다

    // 32bit 운영체제 -> 4바이트 -> 데이터를 4바이트 단위로 처리한다.
    // 64bit 운영체제 -> 한 번에 8바이트 처리 가능 => 주소값도 8바이트 단위로 끊긴다 -> *포인터 변수도 8바이트*
    //32bit 운영체제에서 명령어 한번에 만들어낼수 있는 주소수? 0~2^32-1 -> 42억번지정도 가능 -> 대략 4기가바이트 => 그래서 램이 4기가 바이트 이상은 의미가 없음
    // 64bit는 42억*42억 바이트 만큼

    // 현재 포인터 변수의 크기는 8 바이트다.
    int iSize = sizeof(pInt); //8바이트

    // 현재 포인터 변수는 정수형 표현방식

    int k = 0;
    pInt = &k; //만약 k의 시작 번지수가 100이라면 끝 번지수는? 104, int(4바이트)니깐

    pInt+=1; // 만약 포인터 변수에 1을 더하면? 104가 된다 why?
    // 주소 연산은 일반 정수형 연산을 따르지 않는다.
    // pInt는 일반 정수가 아니라 주소를 가리키는 것, 주소를 보고 -> 다음 주소를 'int'로 생각해라
    // 데이터가 왜곡되지 않으려면 다음 주소는 104번지로 가는게 맞다. 100~103이 해당 정수였는데 101~104를 바라보게 하면 어떤 지랄이 날지 모름.
    // 그래서 포인터변수의 증감의 단위는 정의될 때의 해석 단위(int,char,short,float...)에 따라 다르다.


    // 정리
    // pInt는 int*변수이기 때문에, 가리키는 곳을 int로 해석한다.
    // 따라서 주소값을 1 증가하는 의미는 다음 int위치로 접근하기 위해서 sizeof(int)단위로 증가하게 된다.

    //-----------------------------------------------------------------------------
    // '배열을 정확하게 이해하려면 포인터에 대한 개념이 필요하다'
    // '왜?'

    // 포인터와 배열

    // 배열의 특징
    // 1. 10묶음의 메모리 공간이 연속적이다!
    // 2. 배열의 이름(iArr)은 배열의 시작 주소이다. -> NEW!

    int iArr[10] = {};

    // iArr은 해당 배열의 시작 주소임
//    iArr +1; // -> 포인터 증감과 똑같다. 얘 지금 4바이트 움직인거임

    //참조-> 해당 값으로 가는 것. 결국 메모리로 접근해서 해당 메모리들에 저장된 해당 값(int단위, 4바이트)만큼을 접근해서 해석하는 것
    *(iArr+1)=10; // iArr로부터 1칸 띈 공간에 접근해라 -> 이 1칸의 단위가 int, 즉 4바이트
    // 그러니깐 위의 의미는, iArr+1부터 4바이트까지 접근해서, 4바이트만큼 해석하는 것
    // 이러면 배열의 2번째 값이 10으로 지정된다.

    // 첫 번째 칸에 10을 넣고 싶었으면?
    *(iArr+0) = 10; // => 이래서 배열의 첫 번째 단위가 0이었던 거다!! iArr[0] = 10;


    // 포인터 문제


    //1.
    short sArr[10] = {1,2,3,4,5,6,7,8,9,10};
    // short 2바이트 배열
    int* pI = (int*)sArr;
    // int 포인터
    int iData = *((short*)(pI+2));
    // pI+2는 int 2칸 -> 8바이트 증가 => short(2바이트) 입장에선 4칸 가버림
    // 그래서 결과가 5

    printf("1번문제 정답: %d\n",iData);


    //2.
    char cArr[2] = {1,1};
    // 1바이트씩 차지
    short* pS = (short*)cArr;
    // 근데 short로 해석 2바이트 정수로 해석하게 된다.
    // 그럼 00000001/00000001 로 해석하게 된다.
    // 바꿔 말하면 (8비트가 모두 채워진 1111 1111 에다가 +1 한 값) + (1)
    // 그래서 결과가 255+1 + 1 = 257
    iData = *pS;

    printf("2번 문제 정답: %d\n",iData);

    int test = 100;

    Test(test);

    printf("출력 : %d\n",test);
    // 100

    // 함수 안에서 정의된 a는 전혀 다른 스코프(메모리 스택이 다름)에서 정의된 변수이므로

    // 진짜로 바꾸고 싶다면? 주소를 넘기면 됨

    int* Point = &test;
    Test2(Point);

    printf("출력: %d\n",test);
    // 500


    // 특정 함수에서 내가 실제로 변경시키고 싶은 부분을 건들고 싶다면 주소를 보내면 된다

    scanf_s("%d",&test); // scanf의 역할? 내가 콘솔창에 입력한 데이터를 내 지역창에서 지정된 변수로 넣어준다 => 그래서 내 변수의 주소값을 필요로 한다.
    printf("%d",test);


    // const -> 수정되지 않는 상수

    volatile const int cint = 100;
    // volatile? 휘발성 메모리를 사용하지 않도록 하는 명령어, 여기선 const 지정하면 레지스터에 100값이 남기 때문에 그걸 가져와서 써버린다. 그걸 방지
    // 근데 cLion은 어쨌든 그걸 못 쓰게 하네.

    cint; // 상수화 -> 값이 더이상 바뀌지 않는다.
    // r-value : 상수
    // l-value : 변수
    // 뭐가 뭐인지는 방정식 생각 x=10

    int ii = 10;

    // 그럼 이제 완전히 바꿀 수 없나? 아니. 얘도 메모리에 저장해놓은거라고 생각해라.
    // 그냥 단순히 문법적으로 막아둔 것, 정말 이 안에 있는 값이 완전히 블럭마냥 굳어진게 아니다.

    // 그럼 어떻게 바꿈?
    // 포인터로

//    cp = (int*)&cint;
//
//    *cp = 300;
//    // c++은 이거 막아두네;;
//    //
//
//    printf("%d",cint);

    // 사실 코드 자체가 문제가 있는거임

    // 그럼 const+포인터?


    // const 포인터

    // 1. const
    const int iii = 100;

    // const와 포인터

    int a = 0;
    int* point = &a;

    *point = 1;
    point = nullptr;



    return 0;
}
# 정수형 자료형

```cpp
//
// Created by user on 24. 4. 20.
//
#include <stdio.h>

int main()
{
//    int i = 0;
    //i : 변수
    //int : 자료형
    // 정수형 : char(1),short(2),int(4),long(4),long long(8)
    // 실수형 : float(4),double(8)


    // msb(맨 앞의 비트)로 원래 부호 확인
    // 근데 음수 a 는 a와 더해서 0이 되는 수
    // 그래서 숫자 싹 다 반대로 만들고 1 더한게 음수 값이 됨(2의 보수법)
    // 1111/1111의 음수 값은 0000/0001이 된다.
    // 더하면 승수 올라가서 0000/0000이 된다.

    char data = 255; // 데이터가 양수, 음수 둘 다 인식
    // 모든 데이터가 1로 채워짐 -> -1로 인식
    // 결국 데이터 형의 해석 여부에 따라 같은 데이터도 다르게 인식하게 된다. -> 관점에 따른 해석이 다르다.


    unsigned char data2 = 255; // 데이터가 양수만 인식

    data2 = -1;
    // data2는 1111/1111 (-1)로 비트 값이 들어간다
    // 근데 얘는 양수만 받는거라 최대값인 255로 인식한다.

    printf("%d",data);
    printf("\n%d",data2);


    // int(4바이트)와 long(4바이트)의 차이???


    return 0;
}
```

## 2 . 실수형

```cpp


    // 2. 실수형

    // 실수형 또한 제한된 메모리를 다뤄야 하는데, 방식이 전혀 다름
    // 0~1 사이의 실수 값은 무한 개임
    // 그래서 부동 소수점을 사용함

    // ## 정수와 실수는 메모리의 표현 방식 자체가 다르다 라는 것이 가장 중요
    // 4는 정수로는 0000/0100이지만, 실수론 전혀 다르다
    // 부동 소수점 때문에 실수의 정밀도도 잘 생각해봐야한다.

    // 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현 방식의 피 연산자가 연산될 경우 '명시적으로' 변환하자.


    int a = 4+4.0; // 4.0을 4로 다시 형변환했다. // 이렇게 하지 말고
    float f = 10.2415f + float(20); // 이런 식으로 명시적으로 사용

    float b = 4+4.0;
    printf("\n%d",a); // 4
    printf("\n%f",a); // 0.000000
    printf("\n%d",b); // 0
    printf("\n%f",b); // 8.000000

```

## 3. 연산자

```cpp
    // 3. 연산자
    // 산술 연산자
        // +.-,*,/,%(모듈러스, 나머지 연산자)
        // ++ , --
        // 이 연산자들끼리 우선 순위가 다르다.
    // 대입 연산자
    // 주의
        // 실수끼리는 나머지 연산이 불가능. 둘 중 하나라도 안 된다. %는 피연산자끼리만


    float data3 = 10+10;

    data3 = (int)(10./3.);

    printf("\n%f",data3);



    // 증감 연산자
        // ++.--는 *한 단계* 증가, 감소
        //앞에 붙이냐 뒤에 붙이냐에 따라서도 의미가 달라짐(전치,후치) -> 연산자 우선 순위가 달라짐
            //++data 전위(전치) -> 모든 연산자 우선 순위 중
            // data++ 후위(후치) -> 모든 연산자 우선 순위 중 가장 나중, 대입 연산자 보다도 늦음

    data = 0;
    a = 10;
    data = a++;
    // data에 a를 넣고 a를 증가 -> data에 있는 값은 10
    printf("\n%d",data); //10
    printf("\n%d",a); // 11

    data = ++a;
    printf("\n%d",data); // 12
    printf("\n%d",a); // 12
    // a를 증가하고 data에 넣음 -> 데이터에 있는 값은 11


    // 만약 언제 넣어도 상관 없는 경우라면 그냥 전위로 써라. 그게 더 좋은 습관임
```

## 4. 논리 연산자

```cpp
	//논리 연산자
	//!,||,&&
	// 참,거짓
	// 0이 아닌 수를 모두 참이라고 본다. 특히 1.
	// 거짓은 그냥 0

	true;
	false;

	bool truefalse = false; // 굳이 따지면 정수형이긴 한데 좀 애매함
	bool isTrue = 100; // printf하면 1 -> 완전히 대응되는 개념이 아님

	// 1) 역

	isTrue = true;
	isTrue != isTrue;//뒤집은게 들어간다

	// 근데 이게 일반 정수형 자료형에도 먹힘다.

	int iTrue = 100;
	iTrue = !iTrue; // iTrue에 0이 들어간다

	// 2) 논리곱 && -> 양쪽이 모두 참이어야 한다.
	iTrue = 100 && 200; // 1
	iTrue = 0 && 200; // 0

	// 3) 논리 합
	iTrue = 0 || 100;//1
	iTrue = 1 || 100;//0

	// 주의 : 1만 참인게 아니다. 그리고 bool에 숫
```

## 5. 구문

```cpp
	//5. 구문

	//1) if,else
	int data = 0;

	if (1&&200) {
		data = 200;
	}

	printf("%d", data);

	if (data==100) {
		data = 200;
	}
	else if (data==200) {
		data = 100;
	}
	else {
		data = 100;
	}

	printf("\n%d", data);

	// 비교 연산자
	// ==,!=,<,<=,>,>=

	// 2) switch case

	/*
	switch (데이터)
	{
	case 특정값:
		데이터 == 특정값 일 때 함수 실행
			break;

	case :
		~~
			break;

	// 케이스 여러개를 묶을 수도 있다,.

	case 50:
	case 60:
	case 70:

		break;


	default: // 만약 모든 케이스에 부합하지 않을 때

		break
	}

	*/

	switch (10)
	{
	case 10:
		break;

	case 20:

		break;

	case 50:
	case 60:
	case 70:

		break;

	default:
		break;
	}


	int iTest = 10;
	if (iTest == 10) {

	}
	else if (iTest == 20) {

	}
	else {

	}

	// switch case 는 break가 없으면 default에 적힌 경우까지 실행한다.
	// default는 '항상 하는 것'이라고 생각하는게 편하다. => break 넣어줘야한다.

	//3) 삼항연산자
	// if else에서 조건문을 좀 간단히 쓰고 싶을 때

	iTest == 20 ? iTest = 100 : iTest = 200; // iTest == 20이 true면 앞, 아니면 뒤를 실행


	return 0;

```

## 6. 비트연산자

```cpp
    // 6. 비트 연산자
    // 1) 쉬프트 << , >> -> 비트를 방향대로 한칸 씩 민다

    unsigned char byte = 1; // 0000 0001

    byte <<= 1; // 0000 0010 -> 2배 증가.

    unsigned char byte2 = 10; // 0000 1010

    byte2 <<= 1; // 0001 0101 -> 20 , 2배 증가.

    byte <<= 3; // 8배 증가

    byte >>= 1; // 1/2배 -> 나머지가 생기냐? 아니. 비트 동작을 생각해라
    // 나머지가 있다-> 끝자리가 1이다. => 이게 없어지는거 => 2로 나눈 몫만 생긴다
    // 결국 byte>>n은 2^n으로 나눈 몫

    // 2) 비트 곱(&),합(|),xor(^),반전(~)
    // 2-1) 비트곱 -> 각 자리 비트끼리 비교. 둘 다 1이면 1, 둘 중 하나만 0이어도 0

    // 2-2) 비트합 -> 둘 중 하나만 1이라도 1
    // 2-3) 반전 -> 모든 자리를 반전
    // 2-4) xor -> 같으면 0, 다르면 1 -> 그래서 반전한거끼리 xor 하면 11111111 나옴

       // 7, 전처리기 define 18m
```

# 정수형 자료형

```cpp
//
// Created by user on 24. 4. 20.
//
#include <stdio.h>

int main()
{
//    int i = 0;
    //i : 변수
    //int : 자료형
    // 정수형 : char(1),short(2),int(4),long(4),long long(8)
    // 실수형 : float(4),double(8)


    // msb(맨 앞의 비트)로 원래 부호 확인
    // 근데 음수 a 는 a와 더해서 0이 되는 수
    // 그래서 숫자 싹 다 반대로 만들고 1 더한게 음수 값이 됨(2의 보수법)
    // 1111/1111의 음수 값은 0000/0001이 된다.
    // 더하면 승수 올라가서 0000/0000이 된다.

    char data = 255; // 데이터가 양수, 음수 둘 다 인식
    // 모든 데이터가 1로 채워짐 -> -1로 인식
    // 결국 데이터 형의 해석 여부에 따라 같은 데이터도 다르게 인식하게 된다. -> 관점에 따른 해석이 다르다.


    unsigned char data2 = 255; // 데이터가 양수만 인식

    data2 = -1;
    // data2는 1111/1111 (-1)로 비트 값이 들어간다
    // 근데 얘는 양수만 받는거라 최대값인 255로 인식한다.

    printf("%d",data);
    printf("\n%d",data2);


    // int(4바이트)와 long(4바이트)의 차이???


    return 0;
}
```

## 2 . 실수형

```cpp


    // 2. 실수형

    // 실수형 또한 제한된 메모리를 다뤄야 하는데, 방식이 전혀 다름
    // 0~1 사이의 실수 값은 무한 개임
    // 그래서 부동 소수점을 사용함

    // ## 정수와 실수는 메모리의 표현 방식 자체가 다르다 라는 것이 가장 중요
    // 4는 정수로는 0000/0100이지만, 실수론 전혀 다르다
    // 부동 소수점 때문에 실수의 정밀도도 잘 생각해봐야한다.

    // 정수는 정수끼리, 실수는 실수끼리 연산하되, 두 표현 방식의 피 연산자가 연산될 경우 '명시적으로' 변환하자.


    int a = 4+4.0; // 4.0을 4로 다시 형변환했다. // 이렇게 하지 말고
    float f = 10.2415f + float(20); // 이런 식으로 명시적으로 사용

    float b = 4+4.0;
    printf("\n%d",a); // 4
    printf("\n%f",a); // 0.000000
    printf("\n%d",b); // 0
    printf("\n%f",b); // 8.000000

```

## 3. 연산자

```cpp
    // 3. 연산자
    // 산술 연산자
        // +.-,*,/,%(모듈러스, 나머지 연산자)
        // ++ , --
        // 이 연산자들끼리 우선 순위가 다르다.
    // 대입 연산자
    // 주의
        // 실수끼리는 나머지 연산이 불가능. 둘 중 하나라도 안 된다. %는 피연산자끼리만


    float data3 = 10+10;

    data3 = (int)(10./3.);

    printf("\n%f",data3);



    // 증감 연산자
        // ++.--는 *한 단계* 증가, 감소
        //앞에 붙이냐 뒤에 붙이냐에 따라서도 의미가 달라짐(전치,후치) -> 연산자 우선 순위가 달라짐
            //++data 전위(전치) -> 모든 연산자 우선 순위 중
            // data++ 후위(후치) -> 모든 연산자 우선 순위 중 가장 나중, 대입 연산자 보다도 늦음

    data = 0;
    a = 10;
    data = a++;
    // data에 a를 넣고 a를 증가 -> data에 있는 값은 10
    printf("\n%d",data); //10
    printf("\n%d",a); // 11

    data = ++a;
    printf("\n%d",data); // 12
    printf("\n%d",a); // 12
    // a를 증가하고 data에 넣음 -> 데이터에 있는 값은 11


    // 만약 언제 넣어도 상관 없는 경우라면 그냥 전위로 써라. 그게 더 좋은 습관임
```

## 4. 논리 연산자

```cpp
	//논리 연산자
	//!,||,&&
	// 참,거짓
	// 0이 아닌 수를 모두 참이라고 본다. 특히 1.
	// 거짓은 그냥 0

	true;
	false;

	bool truefalse = false; // 굳이 따지면 정수형이긴 한데 좀 애매함
	bool isTrue = 100; // printf하면 1 -> 완전히 대응되는 개념이 아님

	// 1) 역

	isTrue = true;
	isTrue != isTrue;//뒤집은게 들어간다

	// 근데 이게 일반 정수형 자료형에도 먹힘다.

	int iTrue = 100;
	iTrue = !iTrue; // iTrue에 0이 들어간다

	// 2) 논리곱 && -> 양쪽이 모두 참이어야 한다.
	iTrue = 100 && 200; // 1
	iTrue = 0 && 200; // 0

	// 3) 논리 합
	iTrue = 0 || 100;//1
	iTrue = 1 || 100;//0

	// 주의 : 1만 참인게 아니다. 그리고 bool에 숫
```

## 5. 구문

```cpp
	//5. 구문

	//1) if,else
	int data = 0;

	if (1&&200) {
		data = 200;
	}

	printf("%d", data);

	if (data==100) {
		data = 200;
	}
	else if (data==200) {
		data = 100;
	}
	else {
		data = 100;
	}

	printf("\n%d", data);

	// 비교 연산자
	// ==,!=,<,<=,>,>=

	// 2) switch case

	/*
	switch (데이터)
	{
	case 특정값:
		데이터 == 특정값 일 때 함수 실행
			break;

	case :
		~~
			break;

	// 케이스 여러개를 묶을 수도 있다,.

	case 50:
	case 60:
	case 70:

		break;


	default: // 만약 모든 케이스에 부합하지 않을 때

		break
	}

	*/

	switch (10)
	{
	case 10:
		break;

	case 20:

		break;

	case 50:
	case 60:
	case 70:

		break;

	default:
		break;
	}


	int iTest = 10;
	if (iTest == 10) {

	}
	else if (iTest == 20) {

	}
	else {

	}

	// switch case 는 break가 없으면 default에 적힌 경우까지 실행한다.
	// default는 '항상 하는 것'이라고 생각하는게 편하다. => break 넣어줘야한다.

	//3) 삼항연산자
	// if else에서 조건문을 좀 간단히 쓰고 싶을 때

	iTest == 20 ? iTest = 100 : iTest = 200; // iTest == 20이 true면 앞, 아니면 뒤를 실행


	return 0;

```

## 6. 비트연산자

```cpp
    // 6. 비트 연산자
    // 1) 쉬프트 << , >> -> 비트를 방향대로 한칸 씩 민다

    unsigned char byte = 1; // 0000 0001

    byte <<= 1; // 0000 0010 -> 2배 증가.

    unsigned char byte2 = 10; // 0000 1010

    byte2 <<= 1; // 0001 0101 -> 20 , 2배 증가.

    byte <<= 3; // 8배 증가

    byte >>= 1; // 1/2배 -> 나머지가 생기냐? 아니. 비트 동작을 생각해라
    // 나머지가 있다-> 끝자리가 1이다. => 이게 없어지는거 => 2로 나눈 몫만 생긴다
    // 결국 byte>>n은 2^n으로 나눈 몫

    // 2) 비트 곱(&),합(|),xor(^),반전(~)
    // 2-1) 비트곱 -> 각 자리 비트끼리 비교. 둘 다 1이면 1, 둘 중 하나만 0이어도 0

    // 2-2) 비트합 -> 둘 중 하나만 1이라도 1
    // 2-3) 반전 -> 모든 자리를 반전
    // 2-4) xor -> 같으면 0, 다르면 1 -> 그래서 반전한거끼리 xor 하면 11111111 나옴

       // 7, 전처리기 define 18m
```

### 7. 전처리기 + 비트연산자

```cpp

    // 7, 전처리기 define -> 내가 지정한 구문을 치환할 수 있음
    #define Hungry 1 // 이제부터 Hungry는 1로 받아들여진다.
    int iStatus = Hungry;
    // 왜 쓰냐?
    // 1) 가독성. 화상 데미지 26, 빙결 데미지 52 이런 것들 다 외워야 되냐? x  가독성 올라간다.
    // 2) 유지보수 .만약 Hungry가 바뀐다면? define 부분만 바꾸면 됨. -> 유지보수 측면에서 훨씬 낫다.

    // 7.5 전처리기 + 비트연산자
    // 현재 iStatus는 32비트(int)
    // 총 몇 가지 상태를 해당 비트 안에 조합할 수 있을까? 32가지 상태(한 비트당 하나의 상태)
    #define Thirsty 2 // 2^1 //0x2 //16비트
    #define Cold 4 // 2^2 //0x4
    #define Hot 8//0x8
    #define Tired 16//0x10
    #define Poison 0x20
    #define Poison1 0x40
    #define Poison2 0x80
    #define Poison3 0x100
    #define Poison4 0x200
    #define Poison5 0x400
    #define Poison6 0x800

    iStatus = 0;
    iStatus |= Hungry;
    iStatus |= Thirsty;

    if(iStatus & Thirsty)//둘의 자릿수가 다 1이어야 1, 여긴 두 번째 자리가 1이어야 함
    {

    }
//     특정 자리 비트 제거
     iStatus &= ~Thirsty;
```

### 8. 변수

```cpp
 // 8. 변수
    // 1) 지역변수
    // 우리가 작성하는 변수는 모두 main() 안에 들어가있다. 이걸 함수라고 부름.

    // 2) 전역변수
    // 함수 바깥에 선언하는 변수

    // 함수? 기능. 특정 기능을 기준으로 나누는 것. 필요 기능에 따라 나눠 놓는걸 '모듈화' 라고 한다.


    int sumv = Add(10,20);
    printf("\n%d",sumv);


    // 3) 정적변수
    // 4) 외부변수
    //

```

### 9. 반복문

```cpp
    //9, 반복문

    // 특정 조건을 만족하기까지 지속적으로 반복
    // for문과 while문

    // 1) for()

//    for( /*반복자 초기화*/; /*반복자 조건 체크*/; /*반복자 변경*/)
//    {
//
//    }

    printf("\nOUTPUT TEST START\n");

    for(int i = 0;i<10;++i)
    {
        if(i==2 | i == 3){
            printf("it is continued\n");
            continue;
        }
        printf("OUTPUT TEST\n");


    }

    // 2) while()
    int i = 0 ;
    while(/*조건체크*/i<2)
    {
        printf("output test\n");
        ++i;

    }
```

## 구조체 : 사용자 정의 타입

```cpp
// 구조체 struct
// 사용자 정의 자료형
typedef struct _tagMyST // _tagMyST가 실제 이름
{
    int a; // 이건 변수가 아니다. 그냥 파트의 이름임
    float f;
    // int 와 float을 묶어서 하나의 자료형을 만든 것

}MYST; // MYST가 자료형의 별명

typedef struct _tagBig
{
    MYST k;
    int i;
    char c;

}BIG;

typedef int INT; // 이제 내가 INT a; 라고 해도 프로그램은 int a;와 똑같이 반응한다.

int main()
{

    // 구조체
    MYST t; // 8바이트, int하나 , float 하나
    MYST o = {1,3.14f}; //  이런 식으로 초기롸 가능
    int iSize = sizeof(MYST); //
//    printf("%d", iSize); // 8
    t.a = 10;
    t.f = 1.2312f;

    // 구조체 안에 구조체가 들어갈 수도 있다

    return 0;
}


```

## 포인터 : 주소 저장 변수

```cpp
//
// Created by user on 24. 4. 29.
//

#include <stdio.h>


// 포인터
int main(){

    // 포인터 변수
    // 포인터 : 주소를 가리키는 변수
    // 포인터 변수는 포인터 기능을 하는 변수

    int* pInt = nullptr; // nullptr 는 0과 같음. 아무 주소도 가리키지 않는다는 뜻
    //int*? 별이 붙는 순간, 포인터 변수로 바뀐다. 따라서 *int 변수를 가리키는* 변수가 된다.

    int i = 100;
    int* poInt = &i; // 이제 i의 주소를 저장하는 변수가 됐다.
    // cpp의 가장 큰 능력은 메모리를 직접적으로 변수로 사용할 수 있다는 것


    // 주소로 접근
    *poInt = 110;//*poInt : 참조 -> i로 가는 것
    printf("%d",i); // 110


    // 주소의 단위
    // 바이트 단위 -> 그 사이 비트 단위로는 주소를 쪼갤 수 없다.

    // 그럼 왜 int형만 담을 수 있도록 포인트 변수를 지정할까? (특정 데이터 타입만)
    // 시작 지점을 체크하고, 4바이트만 관리하려고
    // '나는 내가 가리키는 주소를 모두 int라 받아들이고 메모리에 할당된 비트들을 계산해서 할당해줄거다'
    // 그럼 4바이트의 다른 애들을 집어넣어도 상관 없을까?
    // 아님
    // 정수 자료형과 실수 자료형은 애초에 비트 계산 방법 자체가 다름
    // 이건 자료형 배웠을 때 다시 생각해라.

    // 그럼 그런 애를 참조해서 강제로 int화 해버리면 상당히 곤란해짐
    // 애초에 포인터 변수를 할당할 때 앞으로 어떻게 해당 메모리를 해석할 건지도 확인한다.

//    float f = 3.f;
//    int* poiInt = (int*)&f;

    // 정리
    // (자료형) + (*변수명)
    // 자료형 : 해당 포인터에게 전달된 주소를 '해석하는' 단위

    // 그럼 포인터 변수의 크기는 몇일까?
    // int*니깐 int의 크기? x 얜 단지 해석의 방법을 결정해놓은것!


    // 포인터 변수의 크기는 x64인지 x86인지에 따라 플랫폼에 따라 달라진다

    // 32bit 운영체제 -> 4바이트 -> 데이터를 4바이트 단위로 처리한다.
    // 64bit 운영체제 -> 한 번에 8바이트 처리 가능 => 주소값도 8바이트 단위로 끊긴다 -> *포인터 변수도 8바이트*
    //32bit 운영체제에서 명령어 한번에 만들어낼수 있는 주소수? 0~2^32-1 -> 42억번지정도 가능 -> 대략 4기가바이트 => 그래서 램이 4기가 바이트 이상은 의미가 없음
    // 64bit는 42억*42억 바이트 만큼

    // 현재 포인터 변수의 크기는 8 바이트다.
    int iSize = sizeof(pInt); //8바이트

    // 현재 포인터 변수는 정수형 표현방식

    int k = 0;
    pInt = &k; //만약 k의 시작 번지수가 100이라면 끝 번지수는? 104, int(4바이트)니깐

    pInt+=1; // 만약 포인터 변수에 1을 더하면? 104가 된다 why?
    // 주소 연산은 일반 정수형 연산을 따르지 않는다.
    // pInt는 일반 정수가 아니라 주소를 가리키는 것, 주소를 보고 -> 다음 주소를 'int'로 생각해라
    // 데이터가 왜곡되지 않으려면 다음 주소는 104번지로 가는게 맞다. 100~103이 해당 정수였는데 101~104를 바라보게 하면 어떤 지랄이 날지 모름.
    // 그래서 포인터변수의 증감의 단위는 정의될 때의 해석 단위(int,char,short,float...)에 따라 다르다.


    // 정리
    // pInt는 int*변수이기 때문에, 가리키는 곳을 int로 해석한다.
    // 따라서 주소값을 1 증가하는 의미는 다음 int위치로 접근하기 위해서 sizeof(int)단위로 증가하게 된다.

    //-----------------------------------------------------------------------------
    // '배열을 정확하게 이해하려면 포인터에 대한 개념이 필요하다'
    // '왜?'

    // 포인터와 배열

    // 배열의 특징
    // 1. 10묶음의 메모리 공간이 연속적이다!
    // 2. 배열의 이름(iArr)은 배열의 시작 주소이다. -> NEW!

    int iArr[10] = {};

    // iArr은 해당 배열의 시작 주소임
//    iArr +1; // -> 포인터 증감과 똑같다. 얘 지금 4바이트 움직인거임

    //참조-> 해당 값으로 가는 것. 결국 메모리로 접근해서 해당 메모리들에 저장된 해당 값(int단위, 4바이트)만큼을 접근해서 해석하는 것
    *(iArr+1)=10; // iArr로부터 1칸 띈 공간에 접근해라 -> 이 1칸의 단위가 int, 즉 4바이트
    // 그러니깐 위의 의미는, iArr+1부터 4바이트까지 접근해서, 4바이트만큼 해석하는 것
    // 이러면 배열의 2번째 값이 10으로 지정된다.

    // 첫 번째 칸에 10을 넣고 싶었으면?
    *(iArr+0) = 10; // => 이래서 배열의 첫 번째 단위가 0이었던 거다!! iArr[0] = 10;

    return 0;
}
```

학습 필요 정리

구조체

포인터

void
https://wn42.tistory.com/98

동적 할당

cin cout

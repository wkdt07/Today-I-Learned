# Many to One Relationship 1

![Alt text](image-53.png)

![Alt text](image-54.png)

댓글이라는 테이블이랑 게시글이라는 테이블이 따로 존재할거다.

이 둘의 관계를 연결하는 무언가가 존재함. (외래키)

> 여기서 many의 역할은 댓글

> 외래키는 메인인 article이 아닌 comment에 외래키가 존재할거다. 

why? 게시글 id인 a가 댓글에 모두 붙으면 그만인거니깐

![Alt text](image-55.png)

> 결국 Foreign Key는 MANY 부분에 작성해야 한다

![Alt text](image-56.png)

이후 마이그레이션

참고로 저기에 article이라 써서 나중에 아이디 이름이 article_id라고 나옴

![Alt text](image-57.png)


## 댓글 생성 연습

![Alt text](image-58.png)

### 역참조

N -> 1은 '참조' (Comment -> Article)

1 -> N으로 가는게 '역참조' (Article -> Comment) (shb. 자기 새끼한테 가는 방법)

사실 파이썬 문법상 불가능. why? Article에는 Comment에 대한 정보가 아예 없다(애초에 외래키는 Comment에 작성해서 Article에서는 변한게 없음)

이 부분을 django가 도와줘야함.(역참조 기능)

![Alt text](image-59.png)

> how?


![Alt text](image-60.png)


![Alt text](image-61.png)

![Alt text](image-62.png)

## 댓글 구현 - CRUD

<!-- render와 redirect가 따로 없음. why? 한 게시판에서 수정하거나 생성하고 삭제할거니깐 -->

수정은 JS를 배운 이후



### READ

어디서? detail 뷰함수


![Alt text](image-63.png)

![Alt text](image-64.png)



### CREATE

댓글을 생성한다 -> 입력을한다 -> form 클래스를 사용한다. -> DB에 저장해야되는 ModelForm을 만들어야한다

![Alt text](image-65.png)


![Alt text](image-66.png)

![Alt text](image-67.png)

근데 이렇게 들어가면 굉장히 이상한 데이터가 포함된다.

![Alt text](image-68.png)

자기가 참조할 article을 입력받는 부분이 생긴다

> why? modelform 만들 때 fields를 __all__로 설정해서
>
> 이건 '입력 데이터가 필요한' 모든 필드
>
> 언젠가는 입력 받아야 하지만 여기는 아님

![Alt text](image-69.png)

그럼 어디서 받음? view 함수에서 

![Alt text](image-70.png)

잘 생각해보면 detail에 주소엔 article의 pk가 존재함. 

> 이걸 활용!


![Alt text](image-71.png)


![Alt text](image-72.png)

![Alt text](image-73.png)

이제 view 함수 따로 작성해버리면 된다

![Alt text](image-74.png)

다만 아직까지 참조 정보를 넣지 않았다.

![Alt text](image-75.png)

이걸 하려면 comment 인스턴스가 필요하다. 근데 구조상 저기서 구할 방법이 없음. save전에(참조 데이터 넣기 전에) 참조에 쓸 인스턴스가 필요한데, 이걸 구하려면 save 해야됨. 경력직 신입같은거임

그럼 시발 이걸 어떻게???

> 그래서 save()에 옵션이 하나 있다.

> comment = comment_form.save(commit = False)

![Alt text](image-76.png)

< view 완성본 >

![Alt text](image-77.png)

![Alt text](image-80.png)

article.pk 어디서?


![Alt text](image-78.png)

> TIP : No reverse match는 현재 페이지의 url 태그만 보면 된다

![Alt text](image-79.png)

> 얘는 왜 POST일 때와 아닐 때가 나뉘지 않을까?

애초에 이 함수는 POST 요청밖에 안 온다. detail.html을 빌려 쓰기 떄문에 따로 페이지를 렌더링 하는 과정이 없으니 GET 요청도 없다

### DELETE

얘도 삭제 페이지는 필요 없고, 삭제 버튼이 필요

어디에? 

> 댓글 각 옆에 => detail.html


> 과연 valuable routing이 필요할까>

생각할 점

1. 몇 번 댓글을 삭제할건데?
2. 삭제 이후 redirect를 어디로?

결국 valuable routing이 2개 필요함

![Alt text](image-81.png)

![Alt text](image-82.png)

![Alt text](image-83.png)

### 참고

< admin 사이트 등록 >

![Alt text](image-84.png)


< 댓글이 없는 경우의 대체 컨텐츠 >

![Alt text](image-85.png)

< 댓글 갯수 출력 >

![Alt text](image-86.png)

# off-line

## 오늘 내용 키워드

1. 관계 : 두 테이블 사이의 데이터에 연관성이 있다.
   - 1:1(일대일)
     - 하나의 레코드가 다른 테이블의 레코드 1개와 연결된 경우
     - ex) 백준아이디 - 티어
       - 따로 쓰는 경우가 거의 없고, 테이블을 따로 만드는게 딱히 효율이 좋지 않다. => 테이블을 따로 만들 필요가 없다. 
     - ex) 예약정보 - 결제정보
       - 테이블을 나누는게 효율적
       - 따로 쓰는 경우가 많음 
       
   - 1:N (일대다)
     - 하나의 레코드가 다른 테이블의 레코드 여러 개와 연결된 경우
     - ex) 게시글-댓글
     - ex) 사람 - 전화번호
     - Django에서 코딩
       - 외래키는 다(N)쪽에 저장
       - 
   
   - M:N (다대다)
     - 여러 개의 레코드가 다른 테이블의 레코드 여러 개와 연결된 경우
     - ex) 배우-영화 -> 한 영화엔 여러 배우, 한 배우는 여러 영화
     - ex) 인스타 팔로우 기능 -> 트리같은 형태(shb)
  
2. 정참조, 역참조

- 게시글

- 댓글

article = Foreign_ket(Article)

- 정참조 (외래키를 가진 쪽에서 관계가 있는 테이블을 참조)

comment = Comment.objects.get(pk = comment_pk)

comment.article

- 역참조 : 외래키를 가지지 않은 쪽에서 자기를 참조하는 데이터에 접근
    - 특징 : 끝에 '_set'이 추가된다.

> 만약 해당 댓글을 가지고 있는 게시글을 조회하고 싶다면

article = Article.objects.get(pk = article_pk)

> 해당 게싣글의 댓글들

article.comment_set.all()

# 이미지 넣기

- ImageField는 이미지를 이미지 이름으로 저장한다.
- 만약 이 이미지를 출력하고 싶다면 뒤에 .url을 넣으면 된다.
- <img src="{{restaurant.category.image.url}}" alt="">

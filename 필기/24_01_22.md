# 1. Data Structure

데이터 구조 :여러 데이터를 효과적으로 사용,관리하기 위한 구조 (str,list,dict 등)

컴퓨터 공학에선 '자료구조' 라고 함.
각 데이터의 효율적인 저장, 관리를 위한 구조를 나눠 놓은 것.

자료구조     
- 단순 구조

- 선형 구조
           
- 비선형 구조
             
- 파일 구조


<데이터 구조 활용>
-  문자열, 리스트 , 딕셔너리 등 각 제이터 구조의 메서드를 호출하여 다양한 기능을 활용하기
  


### 메서드

*객체에 속한* 함수
지금까지 함수들은 각자 따로 존재하던 함수. 근데 이건 특정 개체(클래스)에 속해있음
->for what? 객체의 상태를 조작하거나, 특정 동작을 수행하기 위해

함수 : input과 output . 여기서 output이 특정 객체를 조정

<메서드 특징>

- 메서드는 클래스 내부에 정의되는 함수
- 클래스는 파이썬에서 '타입을 표현하는 방법'이며 이미 은연중에 사용해봤음 (type 함수.)
```python
print(type(1))

>> <class 'int'>


print(help(str))

>>class str(object) ...

print(help(list))

>> ....
    append(self,object,/)
    Append object to the end of the list. # class list 안에 정립되어 있는 함수(메서드)

근데 보통 함수를 쓰게 된다면 이름과 인자를 통해 호출을 했음. 근데 얘는 ?
a.append()
일반적인 함수 호출과는 다르다 

*** 객체.메서드()  => 앞에 있는 객체의 타입이나 형식에 따라서 메서드가 하는 역할이 달라진다 생각해라.
     
```
- 예를 들어, help 함수를 통해 str을 호출해보면 class 였다는 것을 확인 가능 

- __ : 매직 메서드. 개발자가 직접 사용하는건 아님.



### 지금 시점에 알아야 할 것?

메서드는 어딘가(클래스)에 속해있는 *함수*이며, 각 데이터 타입별로 다양한 기능을 가진 메서드가 존재


*데이터타입객체.메서드()*

ex) str.capitalize() -> 맨 앞 글자를 대문자로

# 시퀀스 데이터 구조

##  1) 문자열

### 문자열 조회.탐색 및 검증 메서드
- s.find(x) : x의 첫 번째 위치를 반환. *없으면* -1을 반환
- s.index(x) : x의 첫 번째 위치를 반환. *없으면* 오류 발생
- s.isalpha(): 알파벳 문자 여부, 중간에 숫자가 섞여 있으면 False (유니코드상. 한국어도 포함.)    *** is로 시작하는건 대부분 True 아니면 False 반환
- s.isupper() : 대문자 여부
- s.islower() : 소문자 여부

```python
my_str = 'banana'

# find
print(my_str.find('a'))   >> 1 '해당 문자열이 존재하는 첫 번째 위치를 반환'

print(my_str.find('z'))   >> -1  '없는건 -1 반환'

# index

print(my_str.index('a'))  >> 1 

print(my_str.index('z'))  >> ValueError : substring not found  !!! *이 아래는 더이상 실행되지 않는다!*

# isalpha

str_1 = 'Hello'

str_2 = '123'

str_3 = '123a'

print(str_1.isalpha())   >> True

print(str_2.isalpha())   >> False

print(str_3.isalpha())   >> False  ## 전부 다 알파벳이냐. -> 숫자 섞인지 여부 확인하면 될 듯


```

1) .find(x)

2) .index : 없었을 때 에러!

3) .isupper() / .islower() : 문자열이 '모두!' 대문자/소문자로 이루어져 있는지 확인. True False 반환

4)

### *********문자열 *조작* 메서드(새 문자열 반환) **********

왜 원본을 변경하지 않고, 새 문자열을 반환할까? str은 불변 타입이라서

- s.replace(old,new[,count]) : 바꿀 대상 글자를 새로운 글자로 바꿔서 반환 => 실제 파이썬에서 [ ] 넣어서 그대로 쓰면 안됨

- s.strip([chars]) : 문자열의 시작과 끝에 있는 공백 혹은 지정 문자를 제거

- s.split(sep = None, maxsplit = -1) -> sep=None, 아무것도 없으면 공백을 기준으로 구분한다. 
: 지정한 문자를 구분자로 문자열을 분리하여 문자열의 * **리스트로** * 반환

- s.title() : 공백 이후 시작되는 애들을 대문자로 바꾸고, 나머지는 소문자로 바꿈

-이외에도 다양

- *** **'separator'**.join(iterable) : iterable 요소들을 원래의 문자열을 구분자로 이용하여 하나의 문자열로 연결 *<-> split*
 -> 문제에서 iterable에 대괄호 들어간건 오타임

```python

# s.replace(old.new[,count]) 
#특이한 형태. 대괄호[]는 뭘까? 3번째 인자를 의미. 선택 인자(없어도 됨)이라는걸 표시하기 위해 []를 넣은 것. 실제로 쓸 때는 [] 안 써도 됨. 그냥 언어 통합 표현법. 베커스-나우르 표기법, 파이썬 ebnf

text = 'hello, world'
new_text = text.replace('world','python')  # 새로운 문자열을 반환하므로 new_text 필요


#strip([chars]) : 문자열의 시작과 끝에 있는 공백 혹은 지정 문자를 제거




```
    

<메서드는 이어서 사용 가능>

```python
text = 'heLLo, woRld!'

new_text = text.swapcase().raplace('l','z')

#주의! 만약 앞에 있는 메서드의 반환값이 None이라면 이어지지 않는다



```

## 2) list

### 탐색

- .append(x)

- .extend(iterable) : 확장. append와 비슷하지만 iterable이 들어가서 그 '요소'를 모두 추가. iterable이니깐 numerical은 불가능. append라면 요소로 풀려서 들어가는게 아니라 통으로 들어가버림.

!!!주의!!!) print(my_list.append('a'))  >> None, append는 새로운 리스트를 반환하는게 아니라 원본을 컨트롤하는거임. 원본을 컨트롤 하는건 반환값이 없다!


- .insert(i, x) : 우리가 *지정한 인덱스* i 위치에 항목 x를 삽입

my_list = [1,2,3]
my_list.insert(3,5) # [1,2,3,5]

- .remove(x) : 리스트에서 첫 번째로 일치하는 항목을 삭제

- .pop(i) : *****굉장히 중요 , 리스트에서 지정한 인덱스의 항목을 제거. ***그리고 그 값을 반환*** , index 안 쓰면 마지막꺼

result= my_list.pop()
print(result) -> 반환된다.

- .clear : 리스트의 모든 항목을 삭제. 주의) 빈 리스트로 만드는거지 리스트를 없애버리는게 아니다. 

### 탐색 및 정렬 메서드

- L.index(x,start,end) : 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 ***반환***
- L.reverse() : 리스트의 순서를 역순으로 변경(정렬x)
- L.sort() : 원본 리스트를 정렬(매개변수 이용 가능), 반환값이 없음 -> print 하면 None. 원본 자체를 바꾸는거임
- L.count(x) : 리스트에서 항목 x의 개수를 ***반환***

```python

##index

print(my_list.index(x)) -> 반환값 존재

##count

my_list = [1,3,2,2,3,3]
count_num = my_list.count(3)
print(my_list.count(3)) #3

##sort

my_list = [3,2,1]
sorted_list = my_list.sort   #None

print(my_list) # [1,2,3]  #원본을 바꾼 거임.

#아무것도 주지 않으면 오름차순임. 그럼 내림차순은? reverse = True

my_list.sort(reverse = True) 
print(my_list)   #[3,2,1]


## reverse -> 원본을 역순으로 나열 , 반환값 없이 원본을 바꾸는 거임.



```


# 3. 복사

## 데이터 타입과 복사

- 파이썬에서는 데이터의 분류에 따라 복사가 달라짐.
- '변경 가능한 데이터 타입'과 '변경 불가능한 데이터 타입'을 다르게 다룸

### 1) 변경 가능한 데이터 타입의 복사

```python
a = [1,2,3,4]

b = a

b[0] = 100

print(b) #a는 과연 바뀌었는가? 파이썬 튜터에서 확인. a도 바뀐다. 이게 가변 데이터에서 주의사항. 왜인지는 강의 다시 확인.



#정수

a = 100

b = a

b = 9

print(b) #9
print(a) #100 -> why? 불변이라 재할당 하는거 아니면 바뀔 일 없음


```



### 2) 복사 유형

## 1. 할당(Assignment)

```python
original_list = [1,2,3]
copy_list = original_list

copy_list[0] = 'hello'

print(original_list) #['hello',2,3]  -> 요소가 바뀌면서 요소가 참조하는 부분이 달라짐

```

할당 연산자(=)를 통한 복사는 해당 객체에 대한 객체 참조를 복사

## 2. 얕은 복사(Shallow copy) by 슬라이싱

슬라이싱 -> 자른 '새로운 리스트'를 반환  => 주소가 아예 다른 리스트임 

```python
a = [1,2,3]
b= a[:]  #이게 얕은 복사
print(a,b) #[1,2,3] [1,2,3]

b[0] = 100
print(a,b)  # [1,2,3] [100,2,3]


##얕은 복사의 한계

a = [1,2,[100,200]]

b = a[:]

b[2][0] =999

print(a)  #[1,2,[999,2,3]]  -> 두 번째 리스트부터는 신규 리스트로 생성 안 되고 재할당만 된다. tutor와 강의 확인

```

## 3. 깊은 복사(Deep Copy)

아예 모듈 사용

```python
import copy

origin_list = [1,2,[1,2]]

deep_copy_list = copy.deepcopy(origin_list)

deep_copy_list[2][0] =999
print(origin_list) #[1,2,[1,2]]  => 변하지 않았다

```

# 5.참고

## 문자열에 포함된 문자들의 유형을 판별하는 메서드

- isdecimal() : 문자열이 모두 숫자 문자(0~9)로만 이루어져 있어야 True
- isdigit() : 


아래는 교재 참고
마지막 페이지는 외우는건 x

# 6. Off-Line

## <매서드> -> 원본 데이터가 변형되냐, 변형되지 않냐가 중요

문자열 매서드 -> IM형 : 문자열 파싱(parsiong)
리스트 매서드 -> IM형 : 방향배열

문자열 매서드 실습 

```python

a = ' Practice makes perfect '

#1. 문자열 a에서 'e'의 개수 세기 ***

print(a.count('e'))

#2. 문자열 a에서 i의 위치 찾기(2가지 방법)***** -> 작년 기출

print(a.find('i')) # i가 존재하지 않으면 -1 반환

print(a.index('i')) # i가 존재하지 않으면 error

#3. 문자열 a의 문자 사이에 .(점) 삽입 **
print(a.replace(' ','.'))

#4. 문자열 a를 공백 기준으로 분리하기 *****
print(a.split(' '))

#5. 문자열 a에서 'makes'를 'made'로 바꾸기 
print(a.replace('makes','made')) -> 기존 a는 바뀌지 않음

#6. 문자열 a를 대문자에서 소문자로 바꾸기, 소문자에서 대문자로 바꾸기
# b=a.swapcase()
# print(b)

# c=b.swapcase()
# print(c)
print(a.lower())
print(a.upper())

#7. 문자열 a의 양쪽 공백 삭제하기 ***
print(a.strip())

#8. 입력된 시간(14:43:20)에서 시간 부분만 보여주기 *****

# t='14:43:20'
# t_1 = t.split(':')[0]
# print(t_1)

t=input().split(':')
print(t[0])

#8-1 주민등록번호 (890927-1212121)에서 생일만 보여주기. 성별 보여주기

birth = '890927-1212121'

print(birth.split('-')[0][2:])

print(birth.split('-')[1][0])

if print(birth.split('-')[1][0]) == (1 or 3):  #왜 이거 뒤에 괄호 없으면 female이 안 나오지?
    print('Male')
else: 
    print('Female')

```

시험에서 원본 데이터가 바뀌는지 안 바뀌는지도 나올 수 있음. (반환 여부)

split()에서 의도치 않게 공백이 들어갈 수 있음
ex) a='hello, world'
    a.split()  >> ['hello', ' world']
    이 때 strip() 사용


==========================================

이어서 메소드 사용하는거는 남용 x


======================================


```python

a=['b','a','n','a','n']

## 반환하지 않는 메서드(void methods) -> 주로 원문을 변경

# 1. 리스트 a의 마지막에 'a' 추가하기 *****stack(후입선출)

a.append('a')
print(a)

# 2. 

#2-1. 리스트 a를 오름차순으로 정렬 -> 원본 변경 ***
a.sort()
print(a)


# 3. 리스트 a를 내림차순으로 정렬 ***
a.sort(reverse=True)
print(a)

# 4. 리스트 a를 역순으로 뒤집기
a.reverse()
print(a)

# 5. 리스트 a에서 문자 'a'를 삭제하기
for i in range(a.count('a')):
    a.remove('a')
print(a)


#========================================

## 반환하는 매서드(return methods) -> 주로 원본을 변경하지 x

#2-2. 리스트 a를 오름차순으로 정렬 -> 원본 변경하지 않는다 how? sorted 사용 ***
print(sorted(a))
#굉장히 중요하니깐 외워놔라


#아니면 얕은 복사 혹은 깊은 복사

b = a[:]
b.sort
print(b)

# 6. 리스트 a의 마지막 요소를 꺼내서 삭제하고 반환값 출력 ***** ->stack(후입선출), popleft메서드, queue(선입선출)

print(a.pop())

# 7. 리스트 a에서 문자 'n'의 갯수 출력
print(a.count('a'))

```



================================================================================

## <복사> -> 얘도 마찬가지로 원본 데이터가 변경되냐, 변경되지 않냐가 중요

### 복사

불변 데이터는 문제가 없다. 가변 데이터일 때는 원본이 변경될 수 있다.

원본 변경 : 할당, 얕은 복사
원본 변경 x : 깊은 복사

1) 할당 -> 복사본을 변경할 경우 원본이 변경 o.
    why? 메모리 주소 값이 같아서

```python
list1 = [1,2,3,4]

list2 = list1       #할당

print(id(list1),id(list2))  #메모리 주소 값이 같다. 그래서 복사본이 변경되면 원본도 변경

```



2) 얕은 복사 : 객체 안에 객체가 있는 경우 원본이 변경 가능


```python


list1 = [1,2,[3,4]]

list2 = list1.copy()       #얕은 복사

print(id(list1),id(list2))  #첫 번째 까진 메모리 주소가 다르다. 근데 안에 있는 중복 리스트를 확인하면 메모리 주소가 같다 -> 이건 똑같이 따라감.

print(id(list1[2]), id(list2[2]) #주소 다름

```



3) 깊은 복사 : 복사본이 변경되어도 원본이 변경 x

```python

import copy

list1 = [1,2,[3,4]]

list2 = copy.deepcopy(list1)       #깊은 복사

print(id(list1),id(list2))  

print(id(list1[2]), id(list2[2])) #주소 같음
```



# 실습 

## ws_5_1

리스트를 스트링으로 만들려면? str(list)로 안된다.
그럼 how?***join 매서드***

```python
def reverse_string(my_str):
    my_list = list(my_str)
    my_list.reverse()
    reverse_str = ''.join(my_list)
    # 리스트를 다시 str로 만들려면 str() 함수로 불가능
    return reverse_str

result = reverse_string("Hello, World!")
print(result)  # !dlroW ,olleH

```


## ws_5_b

```python
data_1 = 'qweqwYadnOyjnsaU4trwg asjnaAn245krRmkfE 42grTasdnHasdnvEasdn asdevadnBasdanEsdkqefqefvaSasdqaeeqqvedwt5hfbsdT24tewfd'
'''
예시코드
arr = [1, 2, 3, 4, 5]
for num in arr:
    print(num, end='')
출력결과 : 12345
'''
data_lst = [] #이게 for 문 안에 있으면 data_lst가 계속 리셋된다.
for data in data_1:
    # data_lst = []
    if data.isupper() or data==' ':
        data_lst.append(data)

print(''.join(data_lst))

```

```python
data_2 = '걉파반샤팝다푸거맥파바자들퍼바배들밥샵파누타히매니배사바파힘다브사부힙헤베내테치대내'
arr = []
for i in range(len(data_2)):
    if i == data_2.find('내') or i == data_2.find('힘') or i == data_2.find('들') or i == data_2.find('다'):
        #조건문에서 index 기준이 아니라 요소 기준으로 하면 겹치는 애들 발생한다.
        arr.append(i)
print(arr)

arr.sort()

print(arr)

for j in arr:
    print(data_2[j],end='')


```

## ws_5_3 튜플 요소 추가와 정렬

```python
# 아래 함수를 수정하시오.
def sort_tuple(a):
    new_tuple = ()
    # new_list = []
    # b = list(a)
    # b.sort()
    # for i in b:
    #     new_list.append(i)
    #     # extend 쓰면 iterable에 들어있는거 싹 다 넣을 수 있음
    # new_tuple = tuple(new_list)
    # return new_tuple
    new_list = []
    new_list.extend(a)
    
    new_list.sort()
    new_tuple = tuple(new_list)
    return new_tuple

    #new_list 안 쓰고 b=list(a), b.sort(), new_tuple = tuple(b) 로 해도 됨


result = sort_tuple((5, 2, 8, 1, 3))
print(result)

```

## ws_5_4 str.title

```python
# 아래 함수를 수정하시오.
def capitalize_words(stri):
    lst = stri.split()
    
    lst_cap = [str_i.capitalize() for str_i in lst]
    result = ' '.join(lst_cap) #sep에 공백 추가하면 리스트 요소 붙일 때 띄어쓰기 가능
    return result

result = capitalize_words("hello, world!")
print(result)

```

만약 .title() 쓰면?


```python
def capitalize_words(stri):
    result = stri.title()
    return result

result = capitalize_words("hello, world!")
print(result)
```


## ws_5_5 

### 만약 list의 갯수가 반복문 내에서 바뀌면? index로 접근이 불가능함.

```python
<잘못된 접근>

for i in range(len(lst)):
    if lst[i] % 2 == 0:
        a = lst.pop(i)
        even.append(a)

result.extend(even)

```


```python
<해답>

def even_elements(lst):
    even = []
    lst.sort(reverse = True) 
    for i in range(len(lst)): #인덱스로 접근이 불가능함. pop 할 때 인덱스 갯수와 순서도 달라지고, lst.pop(i)해버리면 i가 lst보다 커져서 out of range 되어버림
        a = lst.pop() #그냥 밖에서 pop 해라.
        if a % 2 == 0:
            even.append(a)
        # if lst.pop() % 2 == 0:
        #     even.append(lst(pop()))
    result = []
    result.extend(even)
    return result


my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = even_elements(my_list)
print(result)


```

참고로 빈 리스트에서 pop 하면 에러난다. 근데 위 문제에선 리스트 내부에 항상 홀수 놈들이 남아있어서 이런 점이 상관 없어지는거다.
# 0. Data Structure
- Data Structure
- 비시퀀스 데이터구조(set,dict)


# 1. Data Structure

데이터 구조 - 여러 데이터를 효율적으로 관리하기 위한 구조 == 자료구조

메서드 활용도 데이터 구조 활용의 일환

지난 시간에는 문자열과 리스트의 메서드

메서드-객체(클래스)에 속한 함수, 객체(클래스)의 상태를 조작하거나 동작을 수행

메서드는 함수와 생긴 형태가 다르다. 호출을 하는 주체가 정해져있음 
ex) - list.append( ),
    - string.capitalize( )



# 2. 비시퀀스 데이터 구조

- 순서 존재 x => 인덱스 접근 불가능 (슬라이싱도 불가능)


## 1) 세트

고유한 항목들(중복x)의 정렬되지 않은(순서x, 비시퀀스) 컬렉션(요소가 0개 이상, 여러개)

### 세트 메서드

- s.add(x) : 세트 s에 항목 x를 추가. 이미 x가 있다면 변화 없음
- s.clear() : 세트 s의 모든 항목을 제거
- s.remove(x) : 세트 s에서 항목 x를 제거. 항목 x가 없을 경우 key error
- s.pop()
- s.discard(x) : 세트 s에서 항목 x를 제거
- s.update(iterable) : 세트 s에 iterable의 요소들을 추가

```python
# not_set = {} # : 빈 딕셔너리


# void_set = set() # : 빈 세트

my_set = { 'a', 'b', 'c', 1, 2, 3}

# print(my_set) # {'c', 1, 2, 3, 'a', 'b'} 
# 순서가 없어서 실제 출력은 나열 x
# 배치시 정해진 순서에 따른 key가 만들어지긴 함. 이건 이후 파트에서

# # .add(x) ,append와 비슷하지만 얘는 리스트와 다르게 순서가 없음. 마지막에 넣지 x

my_set.add(4)

print(my_set)

my_set.add(4) # 한 번 더 반복하면?

print(my_set) # 똑같다. 중복 x, 교재엔 'd' 넣은 걸로 나옴


# # .clear()

# my_set.clear()

# print(my_set) # set() -> 터미널에도 빈 세트는 이렇게 출력

my_set.remove('a') # 'a' 지워짐``

print(my_set)

# my_set.remove('a')

# print(my_set)  # KeyError: 'a' , 없는걸 지우려 하면 에러가 남 


# # pop() -> 인자를 안 넣으면 마지막 거가 제거되는게 리스트, 여기선 *'임의의'* 요소를 반환 
# # why? 순서가 없기 떄문


element =  my_set.pop() #임의의 요소가 제거되고 반환됨
print(element)
##왜 임의가 아닌거 같은지 다시 강의 봐라 졸았음.

my_set_2 = {'a','b','c','d','e'} 
element_2 =my_set_2.pop()
print(element_2)

# #.update(iterable) == extend()

my_set.update([1,4,5]) #중복된건 안 들어간다. 오류가 나진 x

print(my_set)

# #discard() : 오류 없는 remove()

my_set.discard('z')

print(my_set) # 오류 안 나고, 그냥 위에 있는 my_set과 같음

```

### 세트의 집합 메서드

- set1.difference(set2) == set1 - set2 , 차집합
- set1. intersection(set2) == set1&set2 , 교집합 
- set1.union(set2) == set1|set2 (교집합)
- set1.issubset(set2) : set1의 항목이 모두 set2에 들어있으면 True를 반환 == set1 <= set2 #is/subset
- set1.issuperset(set2) == set1 >= set2 #is/superset



```python

set1 = {0,1,2,3,4}
set2 = {1,3,5,7,9}

print(set1.difference(set2)) #{0, 2, 4}
print(set1.intersection(set2)) #{1, 3}
print(set1.union(set2)) #{0, 1, 2, 3, 4, 5, 7, 9}
print(set1.issubset(set2)) #False
print(set1.issuperset(set2)) #False
```

## 2) 딕셔너리
굉장히 중요, 관통 pjt에서 핵심이었음
왜 중요? key : value  ==> 어떤 언어든 갖고 있는 데이터 타입임.

딕셔너리 : 고유한 항목들(중복x)의 정렬되지 않은(순서x, 비시퀀스) 컬렉션 + key:value 형태

### 딕셔너리 메서드

- D.clear()
  
- D.get(k) : 키 연결된 값을 반환하거나, 키가 없으면 None 혹은 기본 값(default)을 반환  .get(key[,default])
  
- D.get(k,v) : 키 k에 연결된 값(value)를 반환하거나 k가 키에 없으면 기본 값으로 v를 반환
  
- D.keys() : D의 키를 모은 객체를 반환
  
- D.values() : D의 value를 모은 객체를 반환
  
- D.items() : D의 키/값 쌍을 모은 객체를 반환
  
- D.pop(k) : D에서 키 k를 제거하고, 거기에 연결된 value를 반환. 만약 키에 k가 없으면 오류
  
- D.pop(k[,default]) : 만약 k가 없으면 default를 반환
  
- D.setdefault(k[,value]) : D에서 키 k와 연결된 값을 반환. k가 키에 없다면 값 value와 연결한 키 k를 D에 추가하고 value를 반환
  
- D.update(other) : other의 각 키가 D에 있는 키와 일치하는 값이 있다면 value를 덮어쓰기. 만약 D에 없는 키라면 해당 키-값 쌍을 D에 추가.
  - D.update(key = value) 이런 식으로 keyword로도 넣을 수 있음.
 

```python
## 딕셔너리

person = {'name':'Alice' , 'age' : 25}

# 1) .clear() -> 딕셔너리 요소 싹 다 제거

person.clear()

print(person) #{}

# 2) .get(key[,default])

print(person.get('name')) #Alice

print(person.get('country')) #None

print(person.get('country','해당 키가 없습니다.')) #None이 아니라 '해당 키가 없습니다.'이 나옴!

# key in dict != dict.get(key)

# 3) .keys()

print(person.keys()) # dict_keys(['name', 'age']) -> 우리가 아예 본 적 없는 데이터 타입.
#근데 '대괄호로 묶여 있다'라는 점에 집중 => 1. key의 모임 2. 대괄호로 묶여있다면 반복이 가능한 객체(iterable) 이란걸 생각 -> 굳이 데이터 타입을 안 바꿔도 iterable한 곳에 넣을 수 있다!

# 4) .values() -> 키에 접근하지 않아도 value에 접근할 수 o

print(person.values()) # dict_values(['Alice', 25] -> 이것도 대괄호로 묶임
#1. value의 모임 2. iterable

# 5) .items() -> 키와 값 둘 다 쌍을 뽑는거 tuple형태로!

print(person.items()) #dict_items([('name', 'Alice'), ('age', 25)])
#1. key와 value의 튜플로 묶인 모임 2. 쌍으로 나오는 iterable 

# for key, value in person.items(): #-> 언패킹
#     print(key,value) 
    #name Alice
    #age 25

# 6) .pop(key[,default])

print(person.pop('name')) #Alice
print(person) #{'age': 25}
print(person.pop('country')) #KeyError: 'country'
print(person.pop('country','해당 키는 존재하지 않습니다.')) #해당 키는 존재하지 않습니다.


# 7) setdefault : set default -> 기본 값을 할당한다. .get과 비슷한데, 만약 키가 없으면 *딕셔너리에 추가*

print(person.setdefault('country','korea')) #korea

print(person) #{'name': 'Alice', 'age': 25, 'country': 'korea'}

# 8) .update([other]) -요소를 딕셔너리에 넣기

other_person ={
    'name' : 'Jane',
    'Gender' : "Female"
}

person.update(other_person)

print(person) #{'name': 'Jane', 'age': 25, 'country': 'korea', 'Gender': 'Female'}

person.update(age=50)
print(person) #{'name': 'Jane', 'age': 50, 'country': 'korea', 'Gender': 'Female'}

```

# 3. ***참고*** - 메인 컨텐츠만큼 중요

set에서 pop -> 되게 임의 같지 않았음. 이게 왜 이런지


## 1) 해시 테이블

*해시 함수*를 사용하여 *변환한 값*을 *색인(index)*로 삼아 *키(key)와 데이터(value)*를 저장하는 자료구조

=> 데이터를 효율적으로 저장하고 **검색**하기 위해

### 해시테이블 원리 (강의 다시)

딕셔너리를 생각

```python
dict = {
    'john' : '521-1234',
    'lisa' : '521-8976',
    'sandra' : '521-9655'
}

dict.get('lisa') -> 이걸 파이썬은 한 번에 찾는다. 

당연한거 아니냐?

list = [{'john' : '521-1234'}
        {'lisa' : '521-8976'}
        {'sandra' : '521-9655'}
]

이런 형태라면 list를 순회하면서 'lisa'의 데이터를 찾아야 함.

근데 dict는 순서가 없으므로 굳이 순회를 안 하고 key값으로 바로 찾음

리스트의 크기가 작으면 상관 없지만 리스트의 len이 10000 정도 된다면 ? 검색 시간이 너무 오래 걸린다. 

그럼 key값으로 어떻게 한 번에 찾을 수 있냐? #해시테이블을 이용해서
```
(교재 그림 확인)
- 키를 해시 함수를 통해 해시 값으로 변환하고, 이 해시 값을 인덱스로 사용하여 데이터를 저장하거나 검색 =>데이터 검색이 매우 빠르게 이루어짐!

### <해시>

- 임의의 데이터를 고정된(정해진) 값으로 나오게 만든 것.
- 순서가 상관이 없도록 만들어져서 순회 할 필요가 없다

-임의의 크기를 가진 데이터를 고정된 크기의 고유한 값으로 변환하는 것.
이렇게 생성된 고유한 값은 주로 해당 데이터를 *식별*하는데 사용될 수 있음
 - 
    (교재 보고 마저 써라)

### <해시 함수>

- 임의의 길이의 데이터를 입력 받아 고정된 길이의 데이터(해시 값 == 지문)을 출력하는 함수
- 주로 해시 테이블 자료 구조에 사용되며, 매우 빠른 데이터 검색을 위한 컴퓨터 소프트웨어에 유용 

### <set의 요소 & dict의 키와 해시테이블 관계>

- 세트의 요소와 dict의 키는 고유값 -> 해시 테이블을 이용해 중복되지 않는 고유한 값을 저장함
- 세트 내의 각 요소는 해시함수를 통해 해시 값으로 변환되고, 이 해시 값을 기반으로 해시 테이블에 저장됨
    - 세트는 키-벨류가 아닌데? 키=벨류=요소로 하면 상관 없음
- 마찬가지로 딕셔너리의 키는 고유해야 하므로, 키를 해시 함수를 통해 해시 값으로 (계속)


### set의 pop 메서드 예시 - 정수

- 정수 값 자체가 곧 해시 값

```python

my_set = {3,2,1,9,100,4,87,39,10,52}

print(my_set.pop()) #1
print(my_set.pop()) #2
print(my_set.pop()) #3
print(my_set.pop()) #100
print(my_set.pop()) #4 
print(my_set.pop()) #
print(my_set.pop()) #set()


```

과연 이 결과값들의 흐름은 항상 같을까? ex) 9 1 2 9 1 2 ....

#### 놀랍게도 같다.

why? '정수 값 자체가 곧 해시 값' -> 3 2 1 이런 애들이 해시 함수를 거치면 색인 값이 발생. 굳이 복잡하게 색인 값을 난수화 할 필요가 해시 함수한텐 없다. 만약 3을 해시화 하고 싶다면 '키=값=정수'로 놔도 별 문제가 없다. 따라서 *정수값을 그대로 해시의 키, 값으로 넣는다.*

그리고 pop 되는 순서는 해시 테이블에 나열된 순서.(색인이 빠른 순부터) 물론 이 순서가 1,2,3... 순은 아님

But, 문자열은 다름. 문자열은 해시함수가 실행될 때마다 색인값이 새롭게 배정된다. 

```python
my_set = {'a','b','c','d','e','f' }
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())
print(my_set.pop())

#매번 결과가 다르게 나온다.
```
=> 문자열은 실행될 때마다 해시 테이블에 새롭게 놓인다. 


### 파이썬에서의 해시 함수

- hash() -> 해시 값을 보여줌

- 파이썬에서 해시 함수의 동작 방식은 객체의 타입에 따라 달라짐

- 정수와 문자열은 서로 다른 타입이며, 이들의 해시 값을 계산하는 방식도 다름

```python

print(hash(1))
print(hash(1)) #값이 매번 같다 , 물론 이게 1은 1, 2는 2 이런 형태는 아니다. 만약 이렇다면 pop할 때 항상 오름차순으로 나왔어야 함. 

print(hash('a'))
print(hash('a')) #값이 매번 다르다

```

### 파이썬에서의 해시 함수 -정수
(교재 다시 확인)

### 파이썬에서의 해시 함수 -문자열

- 문자열은 *가변적인 길이*를 갖고 있고, 문자열에 포함된 각 문자들의 유니코드 (교재 다시 확인)


### set의 pop 메서드의 결과와 해시테이블의 관계

- pop 메서드는 set에서 *임의*의 요소를 제거하고 반환
- 실행할 때마다 다른 요소를 얻는다는 의미에서의 무작위(random)이 아니라, *'임의'라는 의미에서 무작위(arbitraty)*
- =>pop은 해시 테이블에 나타나는 순서대로 반환하는 것 => random 이 아니라 arbitraty

이걸 hashable 하다고 표현

### hashable

- 대부분의 불변형 데이터 타입은 hashable != 100%
- 어떨 때 non hashable인지 교재의 예시 확인

### hashable과 불변성 간의 관계

### 가변형 객체가 hashable 하지 않은 이유 

- 무결성의 원칙 ->







# 4. Off-Line

## 0) 어제 수업
문자열(불변 시퀀스) 메서드 <-->리스트(가변 시퀀스) 메서드 => 값이 변환되면서 메서드가 적용되냐 아니면 아예 다른 값이 반환되냐 차이 중여

### < sort() 와 sorted의 차이? > -> reverse와 reversed의 차이도 같다.  

공통점 : 오름차순 정렬

차이점 1 : sort는 void method (반환하지 x), sorted는 return method

차이점 2 : sort는 원본 변경 , sorted는 원본이 변경되지 x

reverse와 reversed의 차이: 차이1(순서를 뒤집는 방식), 차이2(반환 값) -> 직접 써보면서 공부해봐라

### < append와 extend의 차이 >

사용 용례가 아예 다르다.
```python
list_a = [1,2,3]
list_b = [4,5,6]

list_a.append(list_b) # err가 나진 x. 리스트가 하나의 요소로 통으로 들어감
# [1,2,3,[4,5,6]]

list_a.extend(list_b) # 리스트의 요소가 하나하나 들어감
# [1,2,3,4,5,6]
```
### < list comprehension >

```python
# 2 <----테스트 케이스
# 3 <----3x3행렬

# 1 2 3
# 4 5 6
# 7 8 9

# 2
# 1 2
# 3 4

T = int(input())

for tc in range(1, T+1):
    N = int(input())
    arr = [list(map(int,input().split()) for _ in range(N))] # _는 그냥 i와 같은 변수명 지정, 자주 쓰는 표현

    print(f'{tc} {arr}')

# 이걸 풀어쓰면? ==============================

T = int(input())

for tc in range(1, T+1):
    N = int(input())
    arr []
    for _ in range(N):
        row = list(map(int,input().split()))
        arr.append(row)
    # arr = [list(map(int,input().split()) for _ in range(N))] ... append가 생략되어 있음.
    print(f'{tc} {arr}')

# => 리스트 컴프리헨션 애용해라. 코드 많이 간략해짐
```


#=====================

## 1) 메서드

메서드 호출 방법 : 객체.메서드() 형태의 구조

## 2) 세트(가변 비시퀀스) 메서드

### <세트 메서드의 공통점> 

*원본 세트를 변경한다.*
->만약 원본 세트를 변경하고 싶지 않다면? 복사본을 만들어라. 그 이후에 작업

### < 세트 메서드 >

- remove()와 dicard()의 차이?

remove는 제거하려는 요소가 원본 세트에 없다면 key error를 발생시킨다. 

```python
my_set = {1,2,3}
element = my_set.remove(4) #이렇게만 해도(print 안 해도) keyerror 발생
print(element) #None
print(my_set) #{1,2,3}

element = my_set.discard(4) #오류 안 남.


# +)

my_set = {} # 딕셔너리

my_set = set() # 세트
```

### < 세트의 집합 메서드 >

합집합, 여집합, 교집합 등 시험 보려면 다 외우긴 해야함. 많이 쓰진 않음(그냥 연산자 씀).


## 3) 딕셔너리 메서드

한 번 다 읽어봐라. 양이 너무 많음.

주의) keys 와 values는 출력되는 형태가 특이함. 직접적으로 보고 싶으면 for문으로 거쳐야함

### < 딕셔너리 메서드 get, pop, setdefault의 공통점과 차이점?? >

공통점: value를 반환

차이점: 
- get --> search 기능 -> search한다고 원본 딕셔너리가 변형되지 않는다!!!, default 설정 가능
- pop --> remove 기능이 있다 -> 원본을 변경(제거)하고 그 값을 반환, default 설정 가능
- setdefault --> add 기능이 있다. -> 원본을 변경(추가)하고 그 값을 반환 *할 수 있음*(무조건은 x)


### < 실습 >
```python
# # 01-23 실습

my_dict = {
    'plust' : ['더하기','빼기'],
    'minus' : ["빼기", '적자'],
    'multiply' : ['곱하기','다양하게'],
    'division' : ['나누기','분열']      
}

# #실습 1. '빼기' 반환(4가지)

print(my_dict['plust'][1])

print(my_dict.get('minus'))[0]

print(my_dict.setdefault('minus')[0])

print(my_dict.pop('minus')[0])

#실습 2. key값 순차적으로 출력(for문 사용)

keys = my_dict.keys()

for i in keys:
    print(i) 

#####
for i in my_dict.keys():
    print(i)

#####
# 딕셔너리는 반복문 돌리면 자동으로 key값이 돈다

for key in my_dict:
    print(key)
 
# 실습 3. 'square' : ['제곱','사각형'] 추가(4가지 방법)
    
#1) setdefault
    
my_dict.setdefault('square',['제곱','사각형'])
print(my_dict)

#2) update

my_dict.update(square=['제곱','사각형']) #여기서 key에 '' 넣으면 안됨
print(my_dict)

#3) update

other = {'square':['제곱','사각형']}
my_dict.update(other)
print(my_dict)

#4) update

my_dict.update({'square':['제곱','사각형']})
print(my_dict)

#5) 메서드 사용 안 하고 -직접 할당

my_dict['square'] = ['제곱','사각형']
print(my_dict)

# #실습 4. 'division' 제거 (2가지 방법)

#1) pop

my_dict.pop('division')
print(my_dict)

#2) del

del(my_dict['division'])
print(my_dict)
```

## 4) 해시

```python
s = {'a','b','c',1,2,3}
element = s.pop()
print(element)
print(s)
```
정수는 1만 반환, 문자열의 경우 임의의 문자열 반환

why? 정수는 고정된 해시코드를 가지고, 문자열의 해시코드는 일정하지 않다.

어떻게 확인하냐? hash( ) 함수

```python
print(hash(1))
print(hash(2))
print(hash('a'))
print(hash('b'))

#정수는 실행할 때마다 일정 값, 문자열은 다른 값이 나온다.
```

결국 random 과 다르다. pdf의 그림이 이해하기 좋게 나와있음.

### 1. 해시테이블의 인덱스(index) != 우리가 아는 시퀀스 자료형의 인덱스(index)


키가 해시함수를 통해 변형된 결과(계산된 값)가 해시테이블의 인덱스. => 요소의 위치가 아니다!

시퀀스 자료형의 인덱스는 요소의 *위치*


### 2. 해시함수는 뭐냐?

- 해시테이블의 해시함수 != hash( )
    - 해시테이블의 해시함수 : 데이터의 저장과 검색에 사용
    - hash( ): 파이썬 내장함수. 객체의 해시 코드를 반환 

### 3. 해시테이블

key-value 쌍으로 저장하는 자료구조. bucket이 존재하며 고유한 위치에 대응 - 해시의 무결성

1) key가 해시 함수를 통해 해시 코드로 변환
2) 이 해시코드를 기반으로 어떤 bucket에 저장할지를 결정

- 장점 : 매우 빠른 검색속도, 중복되지 않는 값(by 무결성)


+) tuple 안에 list가 있는 경우, hash()의 인자로 사용했을 떄 hashable 하지 않아서 typeerror가 날 수 있음.

#### bucket의 위치와 인덱스는 서로 다른 말이다(연관성은 있음)

해쉬값 == 해쉬 인덱스?
### 해시 부분은 따로 또 공부하는게 좋을거다.

### 딕셔너리의 해시구조와 세트의 해시구조의 차이

- 딕셔너리 - 딕셔너리의 key가 해시 함수를 통해 해시코드로 바뀐다. 버킷에 저장되는 형태가 key-value 형태 

- 세트 -key가 없다. 요소가 해시함수를 통해 해시코드로 변환. 변환된 요소인 해시코드가 bucket에 저장. 


## < 해시테이블 > : *고유한 주소*를 정하고 그 주소에 자료를 저장하는 방법

이에 대한 원칙? *무결성 원칙* : 같은 자료는 같은 주소에 저장되어야 한다. -> 자료를 매우 빠르게 찾을 수 있다. 

===================================================================


# 5. 실습

## ws_6_c 
### 반복문에서 일정 위치만큼 띄어 쓰고 싶다면? *반복문 끝나는 자리에서 print()*

```python
for dic in data:
    for key in key_list:
        dic.setdefault(key,'unknown')
        a = dic.get(key)
        print(f'{key}은/는 {a}입니다.')
    print() #한 칸씩 띄어쓰기용    

# name은/는 galxy flip입니다.
# company은/는 samsung입니다.
# is_collapsible은/는 True입니다.
 
# name은/는 ipad입니다.
# company은/는 unknown입니다.
# is_collapsible은/는 False입니다.

# name은/는 galxy fold입니다.
# company은/는 samsung입니다.
# is_collapsible은/는 True입니다.

# name은/는 galxy note입니다.
# company은/는 samsung입니다.
# is_collapsible은/는 False입니다.

# name은/는 optimus입니다.
# company은/는 unknown입니다.
# is_collapsible은/는 False입니다.
```


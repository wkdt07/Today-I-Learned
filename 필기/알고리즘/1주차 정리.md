## 버블 정렬
두 원소의 값을 비교해서 정리하는거

```python
arr = [7,2,5,3,1,4]
def asc(arr, N): #오름차순, n은 정리하고 싶은 갯수
    # for i : n-1 -> 1 (구간의 끝, 마지막 인덱스, 원소가 정렬될 위치)
    for i in range(n-1, 0, -1): #(끝이 1이라, 쓰는건 0)
    # for j : 0 -> i-1 , j는 비교할 두 원소 주 왼쪽 원소의 인덱스
        for j in range(0,i):
            if arr[j] > arr[j+1]: #오름차순은 큰 수를 오른쪽으로
                arr[j],arr[j+1] = arr[j+1],arr[j]
    return arr

def dec(arr, N): #내림차순
    # for i : n-1 -> 1 (구간의 끝, 마지막 인덱스, 원소가 정렬될 위치)
    for i in range(n-1, 0, -1): #(끝이 1이라 쓰는건 0)
    # for j : 0 -> i-1 , j는 비교할 두 원소 주 왼쪽 원소의 인덱스
        for j in range(0,i):
            if arr[j] < arr[j+1]: #내림차순은 작은 수를 오른쪽으로
                arr[j],arr[j+1] = arr[j+1],arr[j]
    return arr

```

```py
def asc(arr,N):
    for i in range(n-1,0,-1):
        for j in range(0,i):
            if arr[j]>arr[j+1]:
                arr[j],arr[j+1] = arr[j+1],arr[j]
    return arr
```

## 카운팅 정렬

항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 *선형 시간에 정렬*하는 효율적인 알고리즘

-> 원소의 갯수를 세는 알고리즘

각 카운트를 집어넣을 [0]*(n+1)의 0으로 이루어진 리스트가 필요 (여기다가 갯수 값을 집어넣는것)

인덱스와 해당 값을 왔다갔다 하게 됨

### 과정

1) 이걸 완벽히 이해해야함. 카운팅 말고도 자주 쓰임
   - Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장
     - counts = [0]*(k+1) : k는 최대 정수
     - +) N개 : [0]xN , 마지막 자리 N : [0]x(N+1)
     - for x in DATA: \n counts[x] += 1

2) 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다. (누적 개수 구하기)
     ```sudo
    for i : 1->k
        counts[i]<-counts[i-1]+counts[i]
    ```

3) counts[k]을 감소시키고 인덱스가 counts[k]+1인 자리에 Temp에 k을 삽입한다

```python
N = 6
K = 9 #0~K
data = [7,2,4,5,1,3] # 0~9, K = 9
counts = [0]*(K+1)
temp =[0]*N # 정렬된 배열 저장소
# counts 배열에 기록하기
for x in data:
    counts[x]+=1
#counts 누적합 구하기
for i in range(1,K+1):
    counts[i] += counts[i-1] + counts[i]

#counts[1] == 4 -> 적어도 1가 나온 횟수로 정렬했을 때 4번째에는 위치해 있다. 
#temp[counts[data[i]]]=data[i] (data[i] == 1)


#  data의 마지막 원소부터 정렬하기
for i in range(N-1,-1,-1): # N-1 -> 0번 인덱스(역순으로 해야 같은 값이 나왔을 때 리스트를 관리할 수 있음, 같은 숫자는 거꾸로 들어감. 좌표 같은 거면 문제가 생김)
    counts[data[i]] -= 1 #개수를 인덱스로 변환(남은 개수 계산)
    temp[counts[data[i]]] =data[i]
print(*temp)
```

#  < 비트 연산자> - 저번 과목 평가

- 비트 연산자
  - & : *비트 단위로* AND 연산을 한다.
  - | : *비트 단위로* OR 연산을 한다.
  - < : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
  - > : 피연산자의 비트 열을 오른쪽으로 이동시킨다 > 이 표시임 
- << 연산자
  - 1 << n : 2**n 즉 , 언소가 n개일 경우의 모든 부분집합의 수를 의미한다.
- & 연산자
  - i & (1 << j) : i의 j번째 비트가 1인지 아닌지를 검사한다.

### 이거 사용례 수업 다시 

### 보다 간결하게 부분집합을 생성하는 방법

```python
arr = [1,2,3,4,5]

n = len(arr)
s= 0

for i in range(1<<n):#2**n-1 까지, i에 따라 다른 부분집합
    for j in range(n): #j번 비트를 이용해서 
        if i & (1<<j):#i의 j번 비트가 1이라면 (arr[j]가 포함되어있는 상태라면)
            print(arr[j],end=",") # 그걸 프린트 
            s += arr[j] #부분집합의 합
    print()

print(s)
```
#아직 코드 이해 못 함. 이해 안 되도 상관 없다지만 수업 다시
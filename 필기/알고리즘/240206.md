# 3. 문자열

## 패턴매칭
문자열을 검색하는 것

- 패턴 매칭에 사용되는 알고리즘들
  - 고지식한 패턴 검색 알고리즘(브루트 포스)
  - 카프-라빈 알고리즘
  - KMP 알고리즘
  - 보이어-무어 알고리즘

### 고지식한 알고리즘(Brute Force) - 만들 줄 알아야 함

본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을일일이 비교하는 방식으로 동작

두 개의 문자열을 비교할 때 짧은 문자열을 하나씩 밀어나가면서 비교할 수도 있음(SHB 스트링 비교 문제에서 쓸 수 있겠다.)


```py

def BruteForce(P,T):
    i = 0 # t의 인덱스 
    j = 0 # p의 인덱스
    while j<M and i < N:
        if t[i] != p[j]:
            i = i-j
            j = -1
        i += 1
        j += 1
    if j == M : return i - M #검색성공
    else: return -1     # 검색 실패
```

```py
# 스트링 비교 문제
T = int(input())

def f(pat,txt,M,N):
    for i in range(N-M+1): # 소스에서 비교 시작 위치
        for j in range(M):
            if txt[i+j] != pat[j]: # 불일치면 다음 시작 위치로
                break

        else: # for문이 잘 끝났으면
            return 1
    # 모든 위치에서 비교가 끝난 경우 -> 찾지 못함
    return 0

for t in range(1,T+1):
    pat = input() # 패스코드
    txt = input() # 소스코드
    M = len(pat)
    N = len(txt)

    ans=f(pat,txt,M,N)
    print(f'#{t} {ans}')


```
- 고지식한 패턴 검색 알고리즘의 시간 복잡도
  - 최악의 경우 모든 텍스트 위치에서 패턴 비교해야하니 O(M*N)
  - 비교횟수를 줄일 방법?

### KMP 알고리즘

- 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행

- 패턴이 틀린 시점으로 *쭉 밀어서* 다시 시작
- 매칭이 실패했을 때 돌아갈 곳을 계산한다


```py
def kmp(t,p):
    N = len(t)
    M = len(p)
    lps = [0] * (M+1)

    #preprocessing 전처리
    j = 0 # 일치한 갯수 == 비교할 패턴 위치
    lps[0] = -1

    for i in range(1,M):  #p[i] 이전에 일치한 갯수
        lps[i] = j
        if 

```


### 보이어 무어 알고리즘

- 오른쪽에서 왼쪽으로 비교
- 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
- 보이어 - 무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동거리는 무려 패턴의 길이만큼이 된다.


>만약 오른쪽 끝 문자랑 패턴 내 문자랑은 다른데, 패턴 내 문자가 키 내에 있을 경우?
> 그 자리로 맞춰놓고 비교

### 문자열 매칭 알고리즘 비교

- 찾고자 하는 문자열 패턴의 길이 m, 총 문자열 길이 n
- 브루트포스 : O(mn)
- 카프 라빈 : theta(n) 세타: 최소한
- KMP : theta(n)



>보이어 무어

- 앞의 두 매칭 알고리즘들의 공통저ㅁ: 텍스트 문자열의 문자를 적어도 한 번씩 훑는다
- 보이어 무어- 텍스트를 다 보지 않아도 된다
- 발상의 전환: 패턴의 오른쪽부터 비교
- 최악의 경우 : theta(mn)
- 입력에 따라 다르지만 일반적으로 theta(n)보단 덜 든다

## 연습문제

## 암호화

## 실습

# offline


### 회문

```py
def is_p(string):
    return string == string[::-1] # True인지 False인지

# T = int(input())
# if is_p(T):
#     print(f'{T}는 회문')

# else:
#     print(f'{T}는 회문이 아니다.')


def find_p(N,M,arr):
    for i in range(N):
        # 각 행에서 가능한 시작 위치, M길이의 회문을 찾기 위해서 N-M의 위치까지만 고려
        for j in range(N-M+1)
            # 가로회문  ---> 시작 j에서 길이가 M 만큼의 부분 문자열
            h = arr[i][j:j+M]
            #세로회문   ---> k행의 i열 문자열 가져오기
            v = [arr[k][i]for k in range(j,j+M)]

            if h == h[::-1]:
                return h
            
            if v == v[::-1]:
                return v

T = int(input())

for t in range(1,T+1):
    N,M = map(int,input().split())
    arr = [list(input()) for _ in range(N)]
    result = find_p(N,M,arr)
    print(f'{t} {result}')
```

### 글자수

```py
T = int(input())

for t in range(1,T+1):
    str1 = input()
    str2 = input()
    cnt_lst = []
    for i in str1: # str도 순회 가능
        cnt_lst.append(str2.count(i))

    result = max(cnt_lst)

    print(f'{t} {result}')
```

### 괄호 친구들

```py
#shb
nums = list(map(str,input()))

# for i in range(len(nums)):
#     if nums[i] == '[' or nums[i] == ']':
#         cnt_p.append(i)
#     elif nums[i] == '{' or nums [i] == '}':
#         cnt_m.append(i)
result = 0
for num in nums:
    if num == '[':
        i = nums.index('[')
        j = nums.index(']')
        a =''.join(nums[i+1:j])
        result += int(a)
        nums.remove('[')
        nums.remove(']')

    if num == '{':
        i = nums.index('{')
        j = nums.index('}')
        a = ''.join(nums[i + 1:j])
        result *= int(a)
        nums.remove('{')
        nums.remove('}')

print(result)
```

```py
word = input()
result = 0

for i in range(len(word)):
    tmp = '' #임시 저장할 공간
    idx = i + 1

    if word[idx] == '[':
        while word[idx] != ']' # 다음게 나올 때까지 
        tmp += word[idx]
        idx += 1
    result += int(tmp)

    if word[idx] == '{':
        while word[idx] != '}' 
        tmp += word[idx]
        idx += 1
    result *= int(tmp)

print(result)
```


### 달력

```py
#shb
t = list(input().split('.'))

cnt = 1

for i in range(1,3):

    #월
    if i == 1 and len(t[i]) == 1:
        if t[i] == 'X':
            cnt += 9
    if i ==1 and len(t[i]) ==2:
        if t[i][1] == 'X' :
            cnt += 2

    # 일
    if 'X' not in t[1]:
        if i == 2 and len(t[i]) == 1:
            if t[i] == 'X':
                cnt += 9

        if i == 2 and len(t[i]) == 2:
            if t[i][1] == 'X':
                if t[i][0] == 'X':
                    if t[i][0] in range(0, 2):
                        cnt += 31

                else:
                    cnt += 9

            if t[i][0] == 'X' and t[i][1] != 'X':
                if t[i][1] in range(2):
                    cnt += 3
                else:
                    cnt += 2


    else:
        if i == 2 and len(t[i])==1:
            if t[i] == 'X':
                cnt *= 9

        if i == 2 and len(t[i])==2:
            if t[i][1] == 'X':
                if t[i][0] == 'X':
                    if t[i][0] in range(0,2):
                        cnt *= 31

                else:
                    cnt *= 9

            if t[i][0] =='X' and t[i][1] != 'X':
                if t[i][1] in range(2):
                    cnt *= 3
                else:
                    cnt *= 2

print(cnt)


```
```py

def month_cnt(month):
    if len(month) == 1:
        if  month== 'X':
            return 9
    
    if len(month) == 2:
        if month[1] =='X': # 10 , 11 , 12 월
            return 3
    
    return 1

def day_cnt(day):
    if day == 'X':
        return 9
    
    if day == 'XX':
        return 22
    
    if day[0] == 'X':
        return 2
    if day[1] == 'X':
        if day[0] != 3:
            return 10
        return 2 # 30일 31일
    return 1
```


### 자동 수학 계산기

```py

'''
100+100-50-30
'''
ex = input()

# 첫 번째 문자가 마이너스인 경우
if ex[0] == '-':
    ex = '0' + ex


# 덧셈 기준으로 분리
word = ex.split('+')
result = 0
for w in word:
    # 뺄셈 기준ㅇ로 분리
    w = w.split('-')

    #첫 번째 요소는 더해줄 값
    inner_ans = int(w[0])

    #나머지 요소들은 빼줄 값
    for i in range(1,len[w]):
        inner_ans -= int(w[i])
    result += inner_ans

print(result)

# 메서드로 쓰면 한 줄
# print(eval(input()))

```
# 1. 배열 : 2차원 배열

## 1) 2차원 배열

1차원 배열을 쌓아놓은것처럼 생김

1차원 리스트를 묶어놓은 리스트

arr = [[0,1,2,3],[4,5,6,7]] -> 2행 4열의 2차원 리스트

세로길이(행의 개수, 층의 개수,row), 가로 길이 (열의 개수, 해당 층에서 몇 번째 칸,column)

웬만하면 y,x 로 표현하지 마라

```python
row = int(input())

arr = [list(map(int,input().split())) for _ in range(row)]

or

row = int(input())

arr = [list(map(int,input())) for _ in range(row)] #빈칸 없이 들어오는건 split() 없이

#만약 0으로 채워진건?

arr = [[0]*N for _ in range(N)] # -> 얜 2차원까지만 가능

arr = [[0]*N]*N    #(x) 불가능

lst = [[0]*10]*10 #[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]....

```

## 2차원 배열의 접근

- 배열 순회
  - 배열의 모든 원소를 빠짐없이 조사 
- 행 우선 순회
  ``` python
  # i행의 좌표
  # j 열의 좌표
    for i in range(n):
        for j in range(m):
            f(arr[i][j])
  ```

- 열 우선 순회
  ``` python
  # i행의 좌표
  # j 열의 좌표
    for j in range(m):
        for i in range(n):
            f(arr[i][j])
  ```

- 지그재그 순회
  - 행 우선이긴 하고, 열이 0 1 2 3(행이 홀수) 3 2 1 0(행이 짝수)

  ``` python
  # i행의 좌표
  # j 열의 좌표
    for i in range(n):
        if i %2 == 0:
            for i in range(m):
                f(arr[i][j])
        else:
            for j in range(m,-1):
                f(arr[i][j])


    or

    for i in range(n):
        for j in range(m) # j: 0 1 2 3으로 가는데 i가 홀수 땐 3 2 1 0이 되어야 함
        # j - (m-1-j-j)*(i%2)-> 홀수 일때만, 짝수일 때만 적용하게 하려면 (i+1)%2를 곱해주면 된다

  ```

 ### *** 델타를 이용한 2차 배열 접근 ***

- 2차 배열의 *한 좌표*에서 4방향의 인접 배열 요소를 탐색하는 방법
- 인덱스 (i,j)인 칸의 상하좌우 칸 (ni,nj) (대각선 방향도 가능)

```sudo
di[] <- [0,1,0,-1] # 방향별로 더할 값

dj[] <- [1,0,-1,0] 

for k: 0 -> 3
    ni <- i+d[k]
    nj <- j+d[k]

```

### 전치 행렬

arr[i][j] -> arr[j][i] by zip 함수 사용도 가능

```python
# i : 행의 좌표, len(arr)
# j : 열의 좌표, len(arr[0])

arr = [[1,2,3],[4,5,6],[7,8,9]] # 3*3 행렬

for i in range(3):
    for j in range(3):
        if i<j: #i==j인 상황 거르기 , # i<j? 오른쪽 위 ,  i>j? 왼쪽 아래 , y=x마냥 i=j 기준 생각
        # if 문이 없다면 양쪽 접근해서 같은 놈을 두 번 바꾸게 된다.
        #<i=2,j=3> (2,3) -> (3,2) / <i=3,j=2> (3,2)->(2,3) 결국 원상복귀  
            arr[i][j],arr[j][i] = arr[j][i],arr[i][j] #서로 뒤바꾸기 위해선 튜플 사용하는게 가장 합리적, 
```

# < 연습문제>


## 부분집합 합(Subset Sum) 문제

- 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분집합 중에서 그 집합의 으ㅓㄴ소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제

- ex) [-7,-3,-2,5,8]라는 집합이 있을 떄, [-3,-2,5]로 가능하므로 참.

- 부분 집합의 수? 2**n개.
  - 원소가 포함되냐(1), 포함되지 않냐(0)에 따라 경우가 나뉨
  - 그럼 이걸 행렬로 나타내면 부분집합을 나타낼 수 있음 (원소가 4개면)[[0,0,0,0,],[0,1,0,0].....] 이런 식으로

```python
#<for문 써서 부분집합 제작>
bit = [0,0,0,0]
for i in range(2):
    bit[0] = i #0번 원소 , 0 또는 1
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
                print(bit) 
                '''SHB.여기다 프린트 해도 되나?'''
```

#### +) < 비트 연산자> - 저번 과목 평가

- 비트 연산자
  - & : *비트 단위로* AND 연산을 한다.
  - | : *비트 단위로* OR 연산을 한다.
  - < : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
  - > : 피연산자의 비트 열을 오른쪽으로 이동시킨다 > 이 표시임 
- << 연산자
  - 1 << n : 2**n 즉 , 언소가 n개일 경우의 모든 부분집합의 수를 의미한다.
- & 연산자
  - i & (1 << j) : i의 j번째 비트가 1인지 아닌지를 검사한다.

### 이거 사용례 수업 다시 

### 보다 간결하게 부분집합을 생성하는 방법

```python
arr = [1,2,3,4,5]

n = len(arr)
s= 0

for i in range(1<<n):#2**n-1 까지
    for j in range(n): #j번 비트를 이용해서
        if i & (1<<j):
            print(arr[j],end=",")
            s += arr[j] #부분집합의 합
    print()

print(s)

#아직 코드 이해 못 함. 이해 안 되도 상관 없다지만 수업 다시

```

#### <연습문제 2>

```python
N = int(input())

arr = list(map(int,input().split()))

#공집합은 항상 0이라 i 범위에 0이 들어가면 안됨
for i in range(1,1<<n):
    s=0
    for j in range(n): 
        if i & (1<<j):
            s += arr[j] 
    if s == 0:
        return True
else: return False
```


#  Off-Line

## < 실습 >

### 색칠하기

```python
#SHB

T = int(input())

def color(arr,i_s,j_s,i_f,j_f):
    for i in range(i_s,i_f+1):
        for j in range(j_s,j_f+1):
            if 0 <= i < 10 and 0 <= j < 10:
                arr[i][j] += 1
    return arr

for t in range(1,T+1):
    N = int(input())
    arr = list([0] * 10 for _ in range(10))
    # print(*arr)
    trial = [list(map(int,input().split())) for _ in range(N)]
    # print(*trial)
    for n in range(N):
        i_s,j_s = trial[n][0],trial[n][1]
        i_f,j_f = trial[n][2],trial[n][3]
        arr = color(arr,i_s,j_s,i_f,j_f)

    count = 0
    for i in range(10):
        for j in range(10):
            if arr[i][j]==2:
                count += 1

    print(f'#{t} {count}')
```


```python
# 1) 1과 2가 겹치면 3 --> 3을 카운트
'''
입력
3
2
2 2 4 4 1
3 3 6 6 2
3
1 2 3 3 1
3 6 6 8 1
2 3 5 6 2
3
1 4 8 5 1
1 8 3 9 1
3 2 5 8 2
'''
T = int(input())

for t in range(1,T+1):
    N = int(input())
    #10x10 2차원 리스트 초기화
    arr = [[0]*10 for _ in range(10)]
    cnt = 0 #count는 메서드가 있으니깐 쓰지 마라

    for k in range(N):
        r1,b1,r2,b2,color = map(int,input().split())
        for i in range(r1,r2+1):
            for j in range(b1,b2+1):
                arr[i][j] += color
                #격자값이 3이면 카운팅
                if arr[i][j] == 3:
                    cnt += 1
    print(f'#{t} {cnt}')
    
# 1번 풀이 문제점? r이 3번 겹쳐도 3
```

```python
# 2) 정확하게 보라색 영역만 카운트

T = int(input())
N = int(input())





for t in range(1,T+1):   
    #10x10 2차원 리스트 초기화
    arr = [[0]*10 for _ in range(10)]
    
    # 색에 따른 카운트 리스트
    r_lst = []
    b_lst = []

    cnt = 0
    for k in range(N):
        r1,b1,r2,b2,color = map(int,input().split())
        for i in range(r1,r2+1):
            for j in range(b1,b2+1):
                if color == 1:
                    r_lst.append([i,j])
                if color == 2:
                    b_lst.append([i,j])                   

    # < 겹치는거 카운트 하는 법 > - 자주 쓰임
    for cm in r_lst:
        cnt += b_lst.count(cm) # r_lst에 있는 cm(인덱스)가 b_lst에 있는 갯수만큼 카운트 
    print(f'#{t} {cnt}')

```

### 부분합



```python
#SHB
T = int(input())

for t in range(1,T+1):
    arr = [1,2,3,4,5,6,7,8,9,10,11,12]

    n = len(arr)
    subset = []
    for i in range(1 << n):
        s = []
        for j in range(n):
            if i & (1 << j):
                s.append(arr[j])
        subset.append(s)  # 부분집합 모음
    n,k = map(int,input().split())

    count = 0
    for sub in subset:
        if (len(sub) == n) and (sum(sub)==k):
            count += 1

    print(f'#{t} {count}')
```

```python
# 1) itertools 모듈 - 간단하고 편하고 좋은데, 오늘 배운거는 좀 다른거(비트 연산자)
'''
import itertools

lst = [1,2,3]

# lst의 순열
result1 = list(itertools.permutations(lst))

# combinations(lst,N) : lst에서 N개의 원소를 가진 모든 조합(원소의 중복 x)

result2 = list(itertools.combinations(lst, 2))
'''

from itertools

T = int(input())
for t in range(1,T+1):
    N,K = map(int,input().split())
    lst = [i for i in range(1,13)] #lst = list(range(1,13))
    lst_comb = itertools.combinations(lst,N) #애초에 크기가 n개인걸 뽑는거니깐
    cnt = 0
    for i in list_comb:
        if sum(i) == K: #부분집합의 합이 K와 같다면
            cnt += 1
    print(f'#{t} {cnt}')
```
#### 비트연산

1. 비트 이동 연산(<<)
   
   ex) 1<<3 이진수 1을 왼쪽으로 3칸 이동 ---> 1000, 10진수 : 8

2. 비트 AND 연산(&)
   
    : 두 이진수의 각 자리를 비교하여, 둘 다 1이면 1, 그렇지 않으면 0
    
    ex) 1100 & 0101 == 0100

```python
# 2) 비트 연산. 이건 외워라
T = int(input())
for t in range(1,T+1):
    N,K = map(int,input().split())
    lst = [i for i in range(1,13)] #lst = list(range(1,13))
    lst_comb = itertools.combinations(lst,N) #애초에 크기가 n개인걸 뽑는거니깐
    cnt = 0

    for i in range(1<<12): #lst의 요소의 개수가 12개이기 때문
        sum_sub =0 # 부분집합의 원소 합계
        subset = [] #현재 부분 집합
        for j in range(12): #집합의 각 원소에 대해 반복
            if i & (1<<j): #i의 이진표현에서 j번째 비트가 1인 경우.
                sum_sub += lst[j] #부분집합의 합계를 갱신
                subset.append(lst[j]) # 부분집합에 원소를 추가

        if len(subset)==N and sum_sub == K:
            cnt += 1
    
    print(f'#{t} {cnt}')
```

## 마법사의 사냥

```python
# SHB
N = int(input())

arr = []

for i in range(N):
    arr_lst = list(map(int,input().split()))
    arr.append(arr_lst)

K = int(input())
lst = []
for y in range(N):
    for x in range(N):
        sumv = 0
        for k in range(1,K+1):
            dir = [(-1,-1),(-1,1),(1,-1),(1,1)]
            for dx,dy in dir:
                ny = k*dy+y
                nx = k*dx+x
                if 0 <= nx < N and 0 <= ny < N:
                    sumv += arr[ny][nx]
            lst.append(sumv)

print(max(lst))
```

```python
#함수 써서 간결하게 
N = int(input())
arr = [list(map(int,input().split())) for _ in range(N)]
K = int(input())

def magic(y,x):
    dy = [-1,1,-1,1]
    dx = [1,1,-1,-1]
    sum_v = 0
    #마법의 방향 대각선(4방향)
    for i in range(4):
        #마법의 파워(현재위치는 제외)
        for j in range(1,K+1):
            ny = y + dy[i] * j
            nx = x + dx[i] * j
            if 0 <= ny < N and 0 <= nx < N:
                sum_v = arr[ny][nx]
    
    return sum_v

sum_lst = [magic(i,j) for i in range(N) for j in range(N)]
print(max(sum_lst))
```
## 폭탄 터트리기

```python
#SHB

N,M = map(int,input().split())

K = int(input())

arr = []
for i in range(N):
    arr.append([char for char in input()])

bomb = []
for lst in arr:
    cnt_x = []
    for i in range(len(lst)):
        if lst[i] == '@':
            cnt_x.append(i)
    bomb.append(cnt_x)
# print(bomb)


for b_y in range(len(bomb)):
    for b_x in bomb[b_y]:
        x = b_x
        y = b_y
        # print(y,x)
        dx = [-1,1,0,0]
        dy = [0,0,1,-1]
        arr[y][x] = '%'
        # bomb_dir = [(-1,0),(1,0),(0,1),(0,-1)]
        # for dir in bomb_dir:
        #     dx,dy = dir
        for i in range(4):
            for k in range(1,K+1):
                nx = x + k*dx[i]
                ny = y + k*dy[i]
                if 0 <= nx < M and 0 <= ny < N:

                    if arr[ny][nx] == '#':
                        break
                    arr[ny][nx] = '%'


for i in arr:
    string = ''.join(i)
    print(string)
```


```python
def bomb(N,M,K,arr):
    dy = [0,0,-1,1]
    dx = [1,-1,0,0]
    for i in range(N):
        for j in range(M):
            if arr[i][j] == '@':
                for d in range(4):
                    for k in range(1,K+1):
                        ny =i + dy[d] * k
                        nx = j + dx[d] * k
                        if 0 <= ny <N and 0 <= nx < N:
                            # 두 가지의 경우를 나눠서
                            if arr[ny][nx] == '_':
                                arr[ny][nx] = '%' #길을 만나면 터지고
                            if arr[ny][nx] =='#':
                                break # 벽을 만나면 반복문 나가라
                arr[i][j] = '%' #폭탄 자리도 터져야 한다, 들여쓰기 주의

N,M = map(int,input().split())
K = int(input())
arr = [list(input()) for _ in range(N)]
bomb(N,M,K,arr)  # 리턴 안 해도 원본 변경

for row in arr:
    print(*row, sep = '')
```



# 자습

## 사각형 그리기

만약 단순히 각각 1씩 늘어나는거면? dir로 접근 안 하고 range 로 접근해도 된다.

+) 이거 lst에 append 할 때 들여쓰기 존나 고생함!!!!!!!!!!!!!!!!!!!

```python
T = int(input())

for t in range(1,T+1):
    N = int(input())
    arr = [list(map(int,input().split())) for _ in range(N)]

    lst = []
    for i in range(N):
        for j in range(N):
            # direct = [(1,0),(1,1)]
            # for dir in direct:
            #     dj,di =dir
                # for k in range(1,N+1):
                #     for l in range(N+1):
                #         ni = i + k*di
                #         nj = j + l*dj
                #         if (i == ni and j == nj):
                #             continue
                #         if (0<=ni<N and 0<=nj<N) and (arr[i][j] == arr[ni][nj]):
                #             area = (ni-i+1)*(nj-j+1)
                #             lst.append(area)
            for ni in range(i+1,N):
                for nj in range(j,N):
                    if (i == ni and j == nj):
                        continue
                    if (0<=ni<N and 0<=nj<N) and (arr[i][j] == arr[ni][nj]):
                        area = (ni-i+1)*(nj-j+1)
                        lst.append(area)
            
            # 어차피 1씩 늘어나는거면 for문 안 쓰고 range 처리 해도 된다.


    max_v = max(lst)
    cnt = lst.count(max(lst))
    print(f'#{t} {cnt}')
```

# 문제풀이

## 6485. 삼성시의 버스 노선

갯수 세기

```py
T = int(input())

for t in range(1,T+1):
    N= int(input())
    cnt = [0]*5001 # 5000번 정류장까지

    #N개의 노선을 정류장에 표시
    for i in range(N):
        A , B = map(int,input().split())
        for j in range(A,B+1): # 이 문제에선 아니지만, 가끔 A와 B의 크기가 반대일 수 있다. 그러니깐
            # 둘 크기를 비교하고 넣어야 하는 경우도 존재. 주의
            cnt[j] += 1

        P = int(input())
        busstop = [int(input()) for _ in range(P)]
        print(f'#{t}', end = ' ')
        for i in busstop: # 출력할 정류장 번호
            print(cnt[i], end = ' ')
# 주의! 이러면 다음 테스트케이스도 일렬로 나옴. 그러니깐 테스트 케이스 하나인 문제는 복붙해서 하나 더 만들어라
        print()

# 리스트 하나하나 돌면서 cnt+=1 하면 수가 많아지면 시간 오류 날 수 있다
```


## 1979. 어디에 단어가 들어갈 수 있을까?


```py

```

## 16286


# Offline

## 월말평가

알고리즘 2문제, 서술형 1문제

알고리즘: 방향배열 없음. 2차원 리스트로 입력 받는건 있음 문제 난이도는 어렵지 않음, 배점이 더 높음 

서술형 : 완전검색 자세히 봐라. Baby-gin 에서 완전 검색으로 어떻게 판단할 수 있는지 그 방법 생각


## 1979 십자말 풀이
# 이거 IM 기출이었다

2차원 완전 검색 50%

문자열 파싱 50%

```py

# SHB


T = int(input())

for t in range(1,T+1):
    N,K = map(int,input().split())
    arr = [list(map(int,input().split())) for _ in range(N)]
    ans = 0

    for i in range(N):
        cnt = 0
        for j in range(N):
            if arr[i][j] == 1:
                cnt += 1
                if (j == N-1 and arr[i][j] == 1) and cnt == K:
                    ans+=1

            if arr[i][j] == 0 :
                if cnt == K:
                    ans += 1
                cnt = 0

    for j in range(N):
        cnt = 0
        for i in range(N):
            if arr[i][j] == 1:
                cnt += 1
                if (i == N-1 and arr[i][j] == 1) and cnt == K:
                    ans += 1

            if arr[i][j] == 0:
                if cnt == K:
                    ans += 1
                cnt = 0

    print(f'#{t} {ans}')
```


```py

T = int(input())

for t in range(1,T+1):
    N,K = map(int,input().split())
    puzzle = [list(map(int,input().split())) for _ in range(N)]
    result = 0

    # 퍼즐의 각 행을 순회
    for i in range(N):
        cnt = 0
        # 1. 행 검사
        for j in range(N):
            if puzzle[i][j] == 1:
                cnt += 1
            
            #현재 퍼즐이 0이거나 행의 마지막일 경우
            if puzzle[i][j] == 0 or j == N-1:
                if cnt == K:
                    result += 1
                cnt = 0 # 카운트 초기화


        #2. 열검사, 같은 상황에서 i j 만 바꾸면 된다. 
        for j in range(N):
            if puzzle[j][i] == 1:
                cnt += 1
            
            #현재 퍼즐이 0이거나 행의 마지막일 경우
            if puzzle[j][i] == 0 or j == N-1: # 열 검사라 위랑 똑같이 이건 j가 맞다
                if cnt == K:
                    result += 1
                cnt = 0 # 카운트 초기화
     

```

## 배관공 콰리오

그리디 -> 특별한 이론이 있는게 아님. if가 있으면 이것에 대한 우선순위를 잘 생각해야함

```py
N,L = map(int,input().split())

leaks = sorted(list(map(int,input().split()))) # 입력받고 오름차순 정렬

cnt = 1 # 첫 번째 구멍을 막기 위해 1로 초기화

curr_leak= leaks[0] # 첫 번째 구멍의 위치

# 두 번째 구멍부터 탐색
for i in range(1,N):
    #현재 테이프로 다음 구멍을 막을 수 있다면,
    if leaks[i] - curr_leak < L: 
        continue
    
    else: # 현재 테이프로 구멍을 막을 수가 없음
        curr_leak = leaks[i] #현재 구멍 위치 갱신
        cnt += 1 #테이프 개수 증가
 
print(cnt)

#hb 굳이 미지수를 s와 e로 놓지 않아도 된다. 이미 s와 L이 존재함

```


## 종강파티

```py
N,M = map(int,input().split())

six_min = float('inf')
one_min = float('inf')

for _ in range(M):
    six_cost, one_cost = map(int,input().split())
    six_min = min(six_min,six_cost)
    one_min = min(one_min,one_cost)

#만약 낱개로 6병 사는게 세트로 6병 사는 것보다 저렴 => 싹 다 낱개로 구매
if one_min * 6 < six_min:
    print(one_min * N)

else: #세트로 사는게 더 싸다
    buy = N//6 #세트로 사는 수
    N %= 6 # 남은 병수
    #남은 병수를 낱개로 사는게 세트 하나로 사는것보다 비싸다면 그냥 세트 하나 사고, 아니면 낱개로 사라
    if N * one_min > six_min:
        buy += 1
        print(buy * six_min)
    
    else: 
        print(buy*six_min + N * one_min)

# 3가지 경우로 나눠야 함

```
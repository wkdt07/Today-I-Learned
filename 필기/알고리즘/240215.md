# 6. 큐(Queue)

## 선형큐

### 큐의 특성

- 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조

- 선입선출구조(FIFO)
  - 큐에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제된다.

### 큐의 구조 및 기본연산

#### 큐의 기본 연산

- 삽입 : enQueue -> 스택에서 push
- 삭제 : deQueue -> 스택에서 pop

- <큐의 사용을 위해 필요한 주요연산>

#### 큐의 연산 과정

1. 공백 큐 생성 : createQueue() -> 미리 크기가 정해진 배열을 생성
   - 크기는 상황에 따라서 결정할 수 있다.
     Q = [0]\*10
     front(저장되지 않은 맨 앞 대가리) = rear(마지막 저장 위치) = -1
2. 원소 A 삽입 : enQueue(A)

   rear += 1
   Q[rear] = A

3. 원소 B 삽입 : enQueue(B)
4. 원소 반환/삭제 : deQueue()
   front += 1 -> 마지막으로 꺼내진 자리를 가리키도록
   tmp = Q[front]

이런 식으로 하다보면 front == rear일 때 큐가 비어있게 된다

### 선형큐

- 1차워 배열을 이용한 큐
  - 큐의 크기 = 배열의 크기
  - front : 마지막으로 꺼내진 원소의 인덱스
  - rear : 마지막으로 저장된 원소의 인덱스
- 상태 표현
  - 초기상태: front == rear == -1
  - 공백상태 : front == rear
  - 포화상태 rear == n-1 -> 큐의 크기가 잘못되었거나 enQueue가 초과된 것

### 큐의 구현

- 초기 공백 큐 생성

  - 크기 n인 1차원 배열 생성
  - front와 rear를 -1로 초기화

- 삽입 : enQueue(item)
  - 마지막 원소 뒤에 새로운 원소를 삽입하기 위해
  - 1. rear 값을 하나 증가시켜 새로운 원소를 삽입할 자리를 마련
  - 2. 그 인덱스에 해당하는 배열원소 Q[rear]에 item을 저장
- 삭제 : deQueue()
  - 가장 앞에 있는 원소를 삭제하기 위해
  - 1. front값을 하나 증가시켜 큐에 남아있는 첫 번쨰 원소 이동
  - 2. 새로운 첫 번쨰 원소를 리턴 함으로서 삭제와 동리한 기능을 함
- 공백 상태 및 포화 상태 검사 : isEmpty(), isFull()
  - 공백상태 : front == rear
  - 포화상태 : rear == n-1
- 검색 : Qpeek()
  - 가장 앞에 있는 원소를 검색하여 반환하는 연산 (가장 마지막에 삭제한 자리인 front의 바로 뒷자리)
  - 현재 front의 한 자리 뒤(front+1)에 있는 원소, 즉 큐의 첫 번째에 있는 원소를 반환

```py
# 큐 생성
N = 10
q = [0] * N
front = rear = -1

rear += 1
q[rear] = 10 # enqueue(10)

rear += 1
q[rear] = 20

rear += 1
q[rear] = 30

while frint != rear: #큐가 비어있지 않으면
    front _- 1       # dequeue()
    print(q[front])
```

## 연습 문제

세 개의 데이터 1,2,3을 차례로 삽입하고 차례로 꺼낸다. output = 1,2,3

```py
queue = []
queue.append(1)
queue.append(2)
queue.append(3)

while queue:
    print(queue.pop(0)) #이게 좋은 방법은 아니다. 새로운 배열을 만드는거라 속도가 느리고 메모리 누수도 심함

```

```py
# 큐 생성
N = 10
q = [0] * N
front = rear = -1

rear += 1
q[rear] = 10 # enqueue(10)

rear += 1
q[rear] = 20

rear += 1
q[rear] = 30

while frint != rear: #큐가 비어있지 않으면
    front _- 1       # dequeue()
    print(q[front])
```

## 원형 큐

### 선형 큐 이용시의 문제점

- 잘못된 포화상태 인식
  - 선형 큐를 이용하여 반복할 경우 rear = n-1일 경우 포화상태로 인식하여 더 이상의 삽입을 수행하지 않게 됨 -> 만약 자리가 앞쪽에 충분히 남아있었으면 낭비임.(일회용)
- 해결방법 1
  - 매 연산이 이루어질 떄마다 저장된 원소들을 배열의 앞부분으로 모두 이동시킴
  - 원소 이동에 걸리는 시간 떄문에 효율성 급락
- 해결방법 2
  - 1차원 배열을 사용하되, 논리적으로는 배열의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정하고 사용
  - rear = n일 때 맨 앞자리를 가리키게 해보면 됨

### 원형 큐의 구조

- 초기 공백 상태

  - front = rear = 0

- index의 순환

  - front와 rear의 위치가 배열의 마지막 인덱스를 가리킨 이후라면 돌아가야함
  - % 연산자를 이용

- front 변수
  - 공백 상태와 포화 상태 구분을 쉽게 하기 위해 \*front 자리는 항상 빈자리로 둔다
- 삽입 위치 및 삭제 위치

  - 삽입 위치 : rear = (rear + 1) % N
  - 삭제 위치 : front = (front + 1) % N

- 포화 상태
  - front == (rear+1)%n # 다음 rear 자리가 front일 떄
- 공백 상태
  - front == rear

### 연결 큐의 구조

- 단순 연결 리스트 (링크드 리스트)를 이용한 큐 -> pop(0)

  - 큐의 원소 : 단순 연결 리스트의 노드
  - 큐의 원소 순서: 노드의 연결 순서. 링크로 연결되어 있음
  - front : 첫 번째 노드를 가리키는 링크
  - rear : 마지막 노드를 가리키는 링크

- 초기, 공백 -> front == rear == Null

### deque

```py
from collections import deque

q = []

for i in range(10000):
    q.append(i)
print('append')

while q:
    q.pop(0)

print('end')

## 시간이 오래 걸림

dq = deque()
for i in range(10000):
    q.append(i)
print('append')

while q:
    q.popleft()

print('end')
```

## 우선순위 큐

구현은 트리 쪽에서

- 우선순위 큐의 특성
  - 우선순위를 가진 항목들을 저장하는 큐
  - FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 된다. -> 우선순위에 대한 데이터를 추가로 갖고있음
- 우선순위 큐의 적용 분야
  - 시뮬레이션 시스템
  - 네트워크 트래픽 제어
  - 운영체제의 테스크 스케줄링

### 배열을 이용한 우선순위 큐

- 배열을 이용하여 우선순위 큐 구현
  - 배열을 이용하여 자료 저장
  - 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
  - 가장 앞에 최고 우선순위의 원소가 위치하게 됨

## 버퍼

### 큐의 활용 - 버퍼

- 버퍼
  - 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역 -동영상을 틀 때 데이터를 미리 갖고 있는다고 생각
  - 버퍼링: 버퍼를 활욯나느 방식 또는 버퍼를 채우는 동작을 의미
- 버퍼의 자료 구조

  - 버퍼는 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용된다.
  - 순서대로 입력/출력/전달되어야 함으로 FIFO인 큐가 활용된다

  데이터를 일시적으로 저장해야 하는 곳에 많이 사용 ex) 키보드 버퍼

### 연습문제 - 마이쮸

# Off-Line

스택과 큐를 왜 배울까? 이 아래 내용은 과목 평가에 무조건 나온다

<스택>

스택 : 후입선출(LIFO)

후입 -> append(), 선출 -> pop()

어디에 활용? DFS

<큐>

큐 : 선입선출(FIFO)

선입 ---> append(), 선출 ---> pop(0) but 시간이 많이 걸린다

해결법

- deque모듈 사용, from collections import deque

선입 --> append(), 선출 --> popleft()

어디에 활용? BFS, 너비우선 탐색, 탐색 순서 물어봄

< 우선순위 큐 > - 단독 문제로도 봐야함

우선순위로 큐가 추가되며, 우선순위가 높은 것부터 제거

우선순위?

heapq모듈 사용 , import heapq

heappush, heappop 사용

heappush : 가장 작은 요소가 항상 첫 번째에 온다.(0번 인덱스) 나머지는 순서가 뒤틀릴 수 있음

heappop : 힙에서 가장 작은 요소를 제거

```py
import heapq

q = []

heapq.heappush(q,4)
heapq.heappush(q,7)
heapq.heappush(q,3)
heapq.heappush(q,1)

print(q) #[1,3,4,7]

ans1 = heapq.heappop(q)
ans2 = heapq.heappop(q)

print(ans1) #1
print(ans2) #3
```

```py
import heapq

q = []

heapq.heappush(q,8)
heapq.heappush(q,4)
heapq.heappush(q,7)
heapq.heappush(q,3)
heapq.heappush(q,1) # 우선순위가 높은 애를 맨 앞으로

print(q) #[1,3,4,7] #[1,3,7,8,4]

ans1 = heapq.heappop(q)
ans2 = heapq.heappop(q)
ans3 = heapq.heappop(q)
ans4 = heapq.heappop(q)


print(ans1) #1
print(ans2) #3
print(ans3) #4
print(ans4) #7
```

## 문제풀이

### 회전

```py
from collections import deque

T = int(input())

for t in range(1,T+1):
    N,M = map(int,input().split())
    lst = deque(map(int,input().split()))

    # for i in range(M):
    #     lst.append(lst.popleft())
    # 이걸 한 줄로 줄일 수 있다
    lst.rotate(-M) # 원소들을 왼쪽으로 M번 이동

    result = lst[0]
    print(f'#{t} {result}')
```

```py
#shb
from collections import deque

T = int(input())

for t in range(1,T+1):
    N,M = map(int,input().split())
    lst = list(map(int,input().split()))
    lst = deque(lst)
    for _ in range(M):
        lst.append(lst.popleft())

    print(f'#{t} {lst[0]}')
```

### 피자굽기

```py
T = int(input())

for t in range(1,T+1):
    N,M = map(int,input().split()) #화덕크기, 피자개수

    cheeses = list(map(int,input().split))

    # 피자 인덱스와 치즈의 양 저장(인덱스는 1부터)
    pizzas = deque([i+1,p] for i,p in enumerate(cheeses))
    oven = deque() # 화덕


    #처음에 화덕에 피자 N개를 넣는다
    for _ in range(N):
        if pizzas:
            oven.append(pizzas.popleft())

    #화덕에 피자가 한 개 남을 때까지 반복

    while len(oven)>1:
        now = oven.popleft() # 화덕에서 피자 하나 꺼냄

        now[1] //= 2

        if now[1]==0: # 치즈가 모두 녹았다면
            if pizzas: # 남은 피자가 있다면 화덕에 새 피자 넣기
                oven.append(pizzas.popleft())

        else: # 치즈가 아직 남아있다면 다시 화덕에 피자 넣기
            oven.append(now)
    print(f'#{t} {oven[0][0]}')
```

```py
from collections import deque

T = int(input())

for t in range(1,T+1):
    N,M = map(int,input().split())
    c_lst = list(map(int,input().split()))
    c_q = deque()
    last = N
    for i in range(N):
        c_q.append([i,c_lst[i]]) # 인덱스와 값 동시에 처리

    while c_q:
        k = c_q.popleft()
        k[1] //= 2
        if k[1] != 0:
            c_q.append(k)

        else:
            if last == M:
                continue
            else:
                c_q.append([last, c_lst[last] // 2])
                last += 1

    print(f'#{t} {k[0]+1}')
```

## 우선순위 큐

### 어글리 넘버

```py
from heapq import heappop as hp
from heapq import heappush as ps

N = int(input())

K = list(map(int,input().split()))

ugly = []
heap = [1]  #최초 힙 1
ps(heap,2)
ps(heap,3)
ps(heap,5)

while len(ugly) < max(K):
    n = hp(heap) # 힙에서 최소값 가져오기

    if n not in ugly: # 중복 피하기
        ugly.append(n)
        ps(ugly,n*2)
        ps(ugly,n*3)
        ps(ugly,n*5)

for i in K:
    print(ugly[i-1],end = ' ')
```

### 정중앙 대학교

```py
from heapq import heappop as hp
from heapq import heappush as ps

lheap = [] # max heap
rheap = [] # min heap
mid = 500

def push(v):
    if mid > v:
        ps(lheap,-v) # max heap 구현을 위해 -1을 곱해준다
    else:
        ps(rheap,v)

n = int(input())

for _ in range(n):
    a,b = map(int,input().split())
    push(a)
    push(b)

    if len(lheap) > len(rheap): #최대 힙의 길이가 최소 힙의 길이보다 길다면
        ps(rheap,mid)
        mid = -hp(lheap) # 꺼낼 때 -1을 곱해준다

    elif len(lheap)<len(rheap): # 최소 힙의 길이가 더 긴 경우
        ps(lheap,-mid)
        mid = hp(rheap)

    print(mid)
```

# 순차 검색(Sequential Search)

일렬로 되어 있는 자료를 순서대로 검색하는 방법
* 가장 간단하고 직관적

* 구현이 쉽지만 검색 대상의 수가 많은 경우 비효율적

#### 검색 과정 (정렬되어 있지 않은 경우)
첫 번쨰 원소부터 순서대로 비교하며 검색

키 값이 동일한 원소를 찾으면 그 원소의 인덱스 반환

자료 구조 마지막에 이를 때까지 검색 대상 찾지 못하면 검색 실패

```
def sequentialSearch(a, n, key):
    i = 0
    while i < n and a[i] != key:
        i += 1
    if i < n:
        return i
    else:
        return -1
```

#### 검색 과정 (정렬되어 있는 경우)
자료를 순차적으로 검색하면서 키 값을 비교하여, 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 검색 종료

```
def sequentialSearch2(a, n, key):
    i = 0
    while i < n and a[i] < key:
        i += 1
    if i < n and a[i] == key:
        return i
    else:
        return -1    
```

# 이진 검색 (Binary Search)

자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법

* 자료가 정렬된 상태여야 함

#### 검색 과정
자료의 중앙에 있는 원소 선택

중앙 원소의 값과 목표 값 비교

작으면 왼쪽 반 크면 오른쪽 반에 대해 새로 검색 수행
```python
def binarySearch(a, n, key):
    start = 0
    end = N - 1
    while start <= end :
        middle = (start + end) // 2
        if a[middle] == key: # 검색 성공
            return true
        elif a[middle] > key:
            end = middle - 1
        else:
            start = middle + 1
    return False        # 검색 실패    
```
```py
# 재귀 함수 이용
def binarySearch2(a, n, key):
    if low > high: # 검색 실패
        return False   
    else:
        middle = (low + high) // 2
        if key == a[middle]: # 검색 성공
            return True
        elif key < a[middle]:
            return binarySearch2(a, low, middle-1, key)
        elif a[middle] < key:
            return binarySearch2(a, middle-1, high, key)
```

# 선택 정렬
주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치 교환

#### 정렬 과정 (On**2)
주어진 리스트 중에서 최소값을 찾는다.

그 값을 리스트의 맨 앞에 위치한 값과 교환

맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정 반복

```py
def SelectionSort(a,N)
    for i range(N-1): 
        min_idx = i
        for j in range(i+1, N):
            if a[min_idx] > a[j]:
                min_idx = j
        a[i], a[min_idx] = a[min_idx], a[i]
```

### 셀렉션 알고리즘(Selection Algorithm)
저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
* 최소값, 최대값 혹은 중간값을 찾는 알고리즘


# OffLine


## 1. 이진탐색

1) 중간값 계산
2) 중간값이 찾고자 하는 값(인자로 받음)보다 크면 왼쪽 부분 탐색
3) 중간값이 찾고자 하는 값(인자로 받음)보다 작으면 오른쪽 부분 탐색

```python

def bs(pages,p): # p 가 찾고자 하는 것
    s = 1 # 탐색 시작점
    e = pages # 탐색 끝 점
    mid = 0
    cnt = 1 # 첫 번째 탐색을 포함

    #찾고자 하는 값(p)를 찾을 때까지 반복
    while p != mid: # p와 중간값이 같아질때까지
        mid = int((s+e)/2) # 1. 증간값 계산
        if mid > p : # 2. 중간값이 찾고자 하는 값보다 크면 왼쪽 부분 탐색
            e = mid
            # e=mid-1 이런 식으로 쓰면 이 문제에선 실제 책 페이지를 건너뛰게 된다. => 정확한 탐색 횟수를 계산 할 수 없다.

        else: # 3. 중간값이 찾고자 하는 값보다 작으면 오른쪽 부분 탐색 (어차피 mid == p면 while 끝남)
            s = mid
        cnt += 1
    return cnt


T = int(input())

for t in range(1,T+1):
    P,Pa,Pb = map(int,input().split())
    A = bs(P,Pa) #A의 탐색횟수
    B = bs(P,Pb) #B의 탐색횟수

    result = 0

    if A == B:
        result = 0
    
    elif A < B: # A가 더 적은 횟수로 찾았으면 A 승리
        result = 'A'
    
    else:
        result = 'B'
    
    print(f'#{t} {result}')
```
input을 파이썬 파일과 같은 디렉토리에 넣어놓고 sys모듈 써라
> 시험 제출할 땐 반드시 지워라!!!!!

```python
import sys
sys.stdin = open("./input.txt","r")
```


### 19646 특별한 정렬

```python

# 1) max,min 활용

T = int(input())

for t in range(1,T+1):
    N = int(input())
    nums = list(map(int,input().split()))
    result = []

    while len(nums) > 0 :
        # max_v = max(nums) 만약 max 못 쓰게 하면?
        
        max_v = float('-inf') #음의 무한대. 계속 max값 초기화, 만약 문제 조건에 max_v에 대한 조건이 없으면 이렇게 써라
        for i in range(len(nums)):
            if nums[i] > max_v:
                max_v = nums[i]

        nums.remove(max_v)
        result.append(max_v)

        min_v = min(nums)
        nums.remove(min_v)
        result.append(min_v)

        print(f'#{tc}',*result[:10]) # 언패킹 연산자로 출력

```

```python
# 2) 오름차순하고 반으로 나눠서 뒷부분 다시 내림차순으로 받고 번갈아서 입력 받으면 됨

T = int(input())

for t in range(1,T+1):
    N = int(input())
    nums = sorted(list(map(int,input().split()))) # 입력받은 정수를 오름차순으로 정렬
    result = []
    lst_f , lst_b = [],[]

    for i in range(len(nums)):
        if i < (len(nums)//2) : # 앞부분은 lst_f에 추가
            lst_f.append(nums[i])
        
        elif i > (len(nums)//2 ) -1: # 뒷 부분은 lst_b에 추가 + -1이 들어가야함
            lst_b.append(nums[i])
        
    lst_b.sort(reverse = True) #뒷부분은 내림차순 정렬

    # 리스트 컴프리헨션은 zip 함수 써야해서 너무 복잡해짐

    for i in range(5):
        result.append(lst_b[i])
        result.append(lst_f[i])

    print(f'{t}', *result)

```

### binary search
```python
n = int(input())

lst = list(map(int,input().split()))

k = int(input())

f_lst = list(map(int,input().split()))

c_lst = []
for f in f_lst:
    if f in lst:
        c_lst.append('O')
    else:
        c_lst.append('X')
#
st = ''.join(c_lst)
print(st)
# ['o','x',]
# print(c_lst)

# for c in c_lst:
#     print(c,end='') 이렇게 해도 됨
```


```python
def bs(target):
    s,e = 0,N
    while s <= e:
        mid = (s+e)//2 # 1. 중간값 찾기
        if A[mid] > target: # 2. mid가 target보다 크면 왼쪽 부분 탐색
            e = mid -1 
        
        elif A[mid] < target: #3. mid가 target보다 작으면 오른쪽 부분 탐색
            s = mid + 1
        
        elif A[mid] == target:
            return True
    return False

N = int(input())
A = tuple(sorted(list(map(int,input().split()))))
K = int(input())
B = tuple(map(int,input().split())) #리스트로 하는거랑 똑같음

for b in B:
    if bs(b):
        print('O',end = '')
    
    else:
        print('X',end = '')
```

### 츄러스

cnt 이용해서 K와 비교

```python

```

```python
N,K = map(int,input().split())
lst = list(int(input()) for _ in range(N))

s,e = 0,max(lst)

while s<= e:
    mid = (s+e)//2
    cnt = 0
    for l in lst: #현재 mid 길이로 츄러스를 잘라 만들 수 있는 츄러스의 개수 총합
        cnt += l//mid
    
    if cnt >= K:
        s = mid +1
    
    else:
        e = mid -1

print(e)

```
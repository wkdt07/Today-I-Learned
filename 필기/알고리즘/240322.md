# 필수문제

- 5185. [파이썬 s/w 문제해결 구현] 1일차 - 이진수
- 7일차 - 최소신장트리

### Kruskal 알고리즘

- 간선을 하나 선택해서 mst를 찾는 알고리즘
  - 1. 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬
  - 2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
       - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
  - 3. n-1개의 간선이 선택될 때까지 2) 반복
- 정렬과 사이클 탐색이 가장 중요
- 정렬은 sort, 사이클 탐색은 union-find 활용

```py
# 1. 전체 그래프를 보고, 가중치가 제일 작은 간선부터 뽑자
#   -> 코드로 구현 : 전체 간선 정보를 저장 + 가중치로 *정렬*

# 2. 방문 처리 : *사이클이 발생하면 안된다!* -> 크루스칼의 가장 중요한 2가지는 정렬과 사이클 탐색
# 사이클 여부? union-find 알고리즘 활용

V,E = map(int,input().split())
edges = [] # 간선 정보들을 모두 저장

for _ in range(E):
    s,e,w = map(int,input().split())

    edges.append([s,e,w])

edges.sort(key=lambda x:x[2]) #가중치를 기준으로 정렬

parents = list(range(V))
def find_set(x):
    if parents[x] == x:
        return x

    # 경로 압축
    parents[x] = find_set(parents[x])
    return parents[x]


def union(x,y):
    x = find_set(x)
    y = find_set(y)

    if x== y:
        return

    if x<y:
        parents[y] = x

    else:
        parent[x] = y


cnt = 0

for s,e,w in edges: #간선들을 모두 확인한다.
    # 사이클이 발생하면 pass, 사이클-> 이미 같은 집합에 속해있다. 1-2-3-1 => 1,2,3이 모두 1을 가리킴
        # how? 이미 같은 집합에 속해 있다면 pass
    if find_set(s) == find_set(e):
        print(s,e,w.'/사이클 발생. 탈락.')
        continue

    print(s,e,w)
    #k
    cnt += 1

    # 사이클이 없으면 통과
    # 사이클이 없으면 방문 처리
    union(s,e) # 얘가 방문처리, 둘에게 같은 대표자를 부여해서 사이클이 나오지 않도록 함
    sum_weight += w

    #k
    if cnt == V -1: # MST 완성! 간선 갯수 V-1
        break
```

# 이론

- 컴퓨팅사고력 - 논리와 증명
- 알고리즘 구현 + Big-O 표기법으로 작성 및 증명해보기
- 여러가지 명제 증명 방법(귀납법, 연역법) 찾아보기

1번은 이진수

```py
T = int(input())

dic = {
    "0" : '0000',
    '1' : '0001',
    '2' : '0010',
    '3' : '0011',
    '4' : '0100',
    '5' : '0101',
    '6' : '0110',
    '7' : '0111',
    '8' : '1000',
    '9' : '1001',
    'A' : '1010',
    'B' : '1011',
    'C' : '1100',
    'D' : '1101',
    'E' : '1110',
    'F' : '1111'
}
for t in range(1,T+1):
    N,k = input().split()
    N = int(N)
    ans = ''
    for n in range(N):
        ans += dic[k[n]]

    print(f'#{t} {ans}')
```

2번 문제는 완탐

3번은 서술형

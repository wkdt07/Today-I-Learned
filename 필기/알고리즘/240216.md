# BFS

- 그래프를 탐색하는 방법 두 가지 중 하나
- 탐색 시작점의 인접한 정점들을 _먼저 모두_ 차례로 방문한 후에, 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식-> DFS는 일단 쭉 가는 느낌이었는데, BFS는 인접한 애들을 먼저 쭉 확인하는 느낌
- 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 큐를 활용함

DFS -> 가장 인접한, 이전노드로 돌아가기 위해 스택을 활용하거나 재귀를 활용함

BFS -> 인접의 인접을 저장하기 위해 큐를 활용(다음에 가야 하는 애들을 큐에 저장해놓고 이걸 선입선출 형태로 활용)

선입선출하면서 다음 노드들이 큐에 들어감

```py
def bfs(G,v): # 그래프  G, 탐색 시작점 v
    visited = [0]*(n+1) # n : 정점의 갯수
    queue = []
    queue.append(v)     #시작점 v를 큐에 삽입

    while queue:            #큐가 비어있지 않은 경우
        t = queue.popleft() # 큐의 첫 번 째 원소 반환

        if not visited[t]: #방문되지 않은 곳이라면
            visited[t] = 1 #방문 표시
            visit(t)            # 정점 t에서 할 일

            for i in G[t]: #t와 연결된 모든 정점에 대해
                if not visited[i]: # 방문되지 않은 곳이라면
                    queue.append(i) #큐에 넣기
```

## [참고] BFS 예제

같은 레벨의 노드끼리 연결되어 있으면? visited에 있으면, 이미 큐에 들어있으면 제외

```py
def bfs(G,v): # 그래프  G, 탐색 시작점 v
    visited = [0]*(n+1) # n : 정점의 갯수
    queue = []
    queue.append(v)     #시작점 v를 큐에 삽입
    visited[v] = 1 # 중복을 방지하기 위해 여기서 방문표시
    # append와 visited처리가 붙어다니면 중복 방지 가능

    while queue:            #큐가 비어있지 않은 경우
        t = queue.popleft() # 큐의 첫 번 째 원소 반환
        visit(t)            # 정점 t에서 할 일

        for i in G[t]: #t와 연결된 모든 정점에 대해
            if not visited[i]: # 방문되지 않은 곳이라면
                queue.append(i) #큐에 넣기
                visited[i] = visited[t] + 1 # n으로부터 1만큼 이동(이건 문제가 얼마나 걸리는지 시간을 물어보는 문제기 때문에)
```

근데 중복이 있을 경우엔 큐의 크기를 잡기 힘듦. 위처럼 append와 visited가 동시에 움직이면 애초에 중복점은 큐에 들어가질 않으므로 상관 없다.

### 연습문제3

bfs는 간선의 갯수에 따라 가는 순서가 달라진다.
1,23,457,6

4,26,157,3

5,26,417,3

```py
'''
V E : V 1~V번까지 V개의 정점. E개의 간선

78
1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7 #입 출 입 출 ....
'''
    #큐생성
    #visited
    #시작점 인큐
    #시작점 방문표시
    #큐가 비워질때까지...(남은 정점이 있으면)
        #t =  deque
        #t에서 할 일
def bfs(s,N): # 시작정점 s, 노드 수 N
    q = []    #큐
    visited = [0] *(N+1)    #visited
    q.append(s)    #시작점 인큐
    visited[s] = 1    #시작점 방문표시
    while q:    #큐가 비워질때까지...(남은 정점이 있으면)
        t = q.popleft()
        #t에서 할 일
        print(t)

        # 다음 노드로
        for i in adjl[t]: #t에 인접인 정점 i
            if visited[i] == 0 : # 방문하지 않은 정점이면
                q.append(i) #인큐
                visited[i] = 1 + visited[t] #방문표시 + 간선까지

# 여기가 시작
V,E = map(int,input().split())

arr = list(map(int,input().split()))

# 인접 리스트
adjl = [[] for _ in range(V+1)]
for i in range(E):
    n1,n2 = arr[i*2],arr[i*2+1]
    adjl[n1].append(n2)
    adjl[n2].append(n1)# 방향이 없는 무향 그래프

bfs(1,V)
```

## 실습문제

### 노드의 거리

저번에 풀었던 갈 수 있는지의 여부도 bfs로 풀면 좋다

```py
def bfs(s,N,G): # 시작정점 s, 노드 수 N
    q = []    #큐
    visited = [0] *(N+1)    #visited
    q.append(s)    #시작점 인큐
    visited[s] = 1    #시작점 방문표시
    while q:    #큐가 비워질때까지...(처리 안 된 남은 정점이 있으면)
        t = q.popleft() # 처리할 정점

        #t에서 할 일
        if t == G:
            return visited[t] - 1 # 최단경로 간선 수, 마이너스는 why? 시작을 1로 시작하기 때문에


        # 다음 노드로
        for i in adjl[t]: #t에 인접인 정점 i
            if visited[i] == 0 : # 방문하지 않은 정점이면
                q.append(i) #인큐
                visited[i] = 1 + visited[t] #방문표시 + 간선까지
    # G까지의 경로가 없을 경우

# 여기가 시작
T = int(input())
for t in range(1,T+1)
    V,E = map(int,input().split())

    arr = list(map(int,input().split()))

    # 인접 리스트
    adjl = [[] for _ in range(V+1)]
    for i in range(E):
        n1,n2 = arr[i*2],arr[i*2+1]
        adjl[n1].append(n2)
        adjl[n2].append(n1)# 방향이 없는 무향 그래프

    S,G = map(int,input().split()) #G에 도착하면 1, 아니면 0

    bfs(S,V,G)
```

### +)

> 시간과 간선을 연결지어서 생각할 수 있다.

> BFS는 시작점이 여러개일 수도 있다. why? 간선 갯수에 따라 갈리는거니깐

# Off-Line

민코딩 밧줄 던지기 - dfs(모든 경우의 수를 찾아야 하는 경우)

민코딩 세균번식 - bfs(퍼져나가는 형태)

## 문제풀이

### 인접행렬 BFS 시작(Low)

```py
'''
6
0 0 0 1 1 0
0 0 0 0 1 0
0 0 0 1 0 0
1 0 1 0 0 1
1 1 0 0 0 0
0 0 0 1 0 0

0 3 4 2 5 1
'''
from collections import deque

n = int(input())
arr = [list(map(int,input().split())) for _ in range(n)]

def bfs(node):
    q = deque([node]) # 시작 노드 추가
    visited = [0] * n # 방문한 노드 기록용
    visited[node] = 1 # 시작 노드 방문 표시

    while q:
        now = q.popleft()
        print(now,end = ' ')
        for i in range(n):
            if arr[now][i] == 0 or visited[i] == 1: #연결되지 않았거나 방문한 노드는 건너뜀
                continue
            visited[i] = 1 #방문표시
            q.append(i)
bfs(0)
```

```py

#shb

from collections import deque

N = int(input())
visited = [0]*(N)

adjL = [list(map(int,input().split())) for _ in range(N)]
arr = [[] for _ in range(N)]
for i in range(N):
    for j in range(N):
        if adjL[i][j] == 1:
            arr[i].append(j)

def bfs(s):
    p_lst = []
    q = []
    q = deque(q)
    q.append(s)
    visited[s] = 1
    while q:
        t = q.popleft()
        p_lst.append(t)

        for k in arr[t]:
            if not visited[k]:
                q.append(k)
                visited[k] = 1

            else:
                continue
    return p_lst


print(*bfs(0))
```

### 이사

```py
from collections import deque
n,m = map(int,input().split()) #지역의 수 n, 버스 노선의 수 m
arr = [[0]*(n+1) for _ in range(n+1)] # 인접 행렬 초기화
visited = [0]*(n+1) # visited 초기화
cnt = 0

for _ in range(m):
    node1,node2 = map(int,input().split())
    arr[node1] = node2
    arr[node2] = node1 # 양방향

r,k = map(int,input().split()) #출근지역 r , 최대 버스 탑승 횟수 k

def bfs(node):
    global cnt
    q = deque([node])
    visited[node] = 1
    while q:
        now = q.popleft()

        if visited[now] - 1 <= k: # 현재 간선 갯수가 k 이하의 버스 탑승
            cnt += 1
        if visited[now] - 1 > k: # 넘어가면 더 이상 탐색할 필요 없음(어차피 계속 이것보다 크게 나올거임)
            break

        for i in range(1,n+1):
            if arr[now][i] == 0  or visited[i] > 0:
                continue
            visited[i] = visited[now] + 1
            q.append(i)
bfs(r)
print(cnt)
```

```py

# shb

from collections import deque

def bfs(s):
    q = deque([])
    q.append(s)
    visited[s] = 1

    while q:
        t = q.popleft()

        for k in arr[t]:

            if not visited[k]:
                q.append(k)
                visited[k] = visited[t] + 1
    return visited


N,M = map(int,input().split()) # N은 노드 수, M은 모든 간선 수

visited = [0] * (N+1)

arr = [[] for _ in range(N+1)]
for _ in range(M):
    i,j = map(int,input().split())
    arr[i].append(j)
    arr[j].append(i) # 방향성 없음

# print(arr)
R,K = map(int,input().split()) #R은 현재 위치

cnt = 0
for i in bfs(R)[1:]:
    if i <= K+1:
        cnt += 1

print(cnt)
```

### 출근(mid)

```py
from collections import deque
n,m = map(int,input().split()) #지역의 수 n, 버스 노선의 수 m
arr = [[0]*(n+1) for _ in range(n+1)] # 인접 행렬 초기화
visited = [0]*(n+1) # visited 초기화

for _ in range(m):
    node1,node2 = map(int,input().split())
    arr[node1] = node2
    arr[node2] = node1 # 양방향

# 화재 지역 봉쇄
fire = int(input())
for i in range(1,n+1):
    arr[i][fire] = 0
    arr[fire][i] = 0


def bfs(node):
    q = deque([node])
    visited[node] = 1
    while q:
        now = q.popleft()
        for i in range(1,n+1):
            if arr[now][i] == 0  or visited[i] > 0:
                continue

            if i ==n: # 종료조건 추가
                return visited[now]
            visited[i] = visited[now] + 1
            q.append(i)
bfs(r)
print(cnt)
```

```py
from collections import deque

N,M = map(int,input().split()) # N은 지역수, M은 관계 수
vst = [0] *(N+1)
arr = [[] for _ in range(N+1)]

for _ in range(M):
    i,j = map(int,input().split())
    arr[i].append(j)
    arr[j].append(i)

T = int(input())

# print(arr)

def bfs(s,N,T):
    q = deque([])
    q.append(s)
    vst[s] = 1
    while q:
        t = q.popleft()
        if t ==  N:
            return vst
        if t ==  T:
            continue
        else:
            for k in arr[t]:
                if not vst[k]:
                    q.append(k)
                    vst[k] = 1 + vst[t]

    return -1

result = bfs(1,N,T)[N] - 1
print(result)
```

### 노드의 거리

```py
from collections import deque

def bfs(s,e):
    q = deque([(s,0)]) #시작노드, 초기거리 0

    while q:
        n,cnt = q.popleft()
        if not vst[n]: # 노드 방문하지 않았으면 방문 표시
            vst[n] =1
        for i in arr[n]:
            if not vst[i] and i == end: #목표노드에 방문하면 거리 반환
                return cnt += 1
            elif not vst[i]:
                q.append((i,cnt+1))
    return 0

T = int(input())

for t in range(1,T+1):
    V,E = map(int,input().split())
    arr = [[] for _ in range(V+1)]
    vst = [0] * (V+1)

    for i in range(E):
        node1,node2 = map(int,input().split())
        arr[node1].append(node2)
        arr[node2].append(node1)

    s,e = map(int,input().split())
    print(f'#{t} {bfs(s,e)}')
```

```py
# shb
# 간선 수 구하기

from collections import deque
T = int(input())

def bfs(s,e):
    q = deque([])
    q.append(s)
    vst[s] = 1

    while q:
        t = q.popleft()
        for k in arr[t]:
            if not vst[k]:
                q.append(k)
                vst[k] = vst[t] + 1
    if vst[e]:
        return vst[e] -1
    else:
        return 0

for t in range(1,T+1):
    V,E = map(int,input().split())
    vst = [0] * (V+1)
    arr = [[] for _ in range(V+1)]
    for _ in range(E):
        i,j = map(int,input().split())
        arr[i].append(j)
        arr[j].append(i)
    S,G = map(int,input().split()) #s,e
    print(f'#{t} {bfs(S,G)}')


```

### 미로의 거리

```py
from collections import deque

dir = [(1,0),(-1,0),(0,1),(0,-1)]

def start(): #시작위치 찾는 함수
    for i in range(N):
        for j in range(N):
            if arr[i][j]=='2':
                return i,j
def bfs(y,x):
    vst[y][x] = 1 #시작위치 방문 표시
    while q:
        cy,cx = q.popleft()
        if arr[cy][cx] == '3': #도착 위치면 거리 반환
            return vst[cy][cx] -2 #시작과 끝을 제외한 거리
        for dy,dx in dir:
            ny,nx = cy+dy,cx+dx
            if 0 <= ny <N and 0 <= nx < N:
                if arr[ny][nx] != '1' and vst[ny][nx] == 0: #벽이 아니고, 방문하지 않았다면
                    vst[ny][nx] = vst[cy][cx] + 1 #거리 갱신
                    q.append((ny,nx))
    return 0

T = int(input())
for t in range(1,T+1):
    N = int(input())
    arr = [list(input()) for _ in range(N)]
    vst  [[0]*N for _ in range(N)]
    si,sj = start()
    result = bfs(si,sj)
    print(f'#{t} {result}')
```

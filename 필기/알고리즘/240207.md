# 4. 스택 1
>파이썬에선 append와 pop
## 스택의 특성
- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
- 스택에 저장된 자료는 *선형구조*
  - 선형구조 : 자료 간의 관계가 1대1의 관계
  - 비선형구조 : 자료 간의 관계가 1대 n의 간계 ex) 트리
- 스택에 자료를 삽입하거나 스택에서 자료를 꺼낼 수 있다
  > 마지막에 삽입한 자료를 가장 먼저 꺼낸다. 후입선출(LIFO)
  
## 스택을 구현하기 위한 자료구조와 연산
- 자료구조: 자료를 선형으로 저장할 저장소
  - 배열 사용 가능
  - 저장소 자체를 스택이라 부르기도 함
  - 스택에서 마지막 삽입된 원소를 *top* 혹은 *스택포인트 sp* 라고 함

- 연산
  - 삽입 : 저장소에 자료를 저장. Push
  - 삭제 : 저장소에서 자료를 꺼냄. 선입후출. Pop
  - 스택이 공백인지 아닌지 확인하는 연산? isEmpty
  - 스택의 top에 있는 item(원소)를 반환하는 연산? peek


## 스택의 구현

### 스택의 push 알고리즘
- append 메소드를 통해 리스트의 마지막에 데이터를 삽입

- 알고리즘 문제에서도 정해진 배열 크기 내에서  top 등을 통해 활용 가능(사이즈가 큰걸 다룰 때)

```py
def push(item):
    s.append(item)
 return s
```


```py
def push(item,size): # 디버깅용 코드
    global top

    top += 1
    if top == size: # 더 이상 증가할 자리가 없으면
        print('overflow!')

    else:
        stack[top] = item


size = 10
stack - [0]*size # 최대 사이즈 크기만큼 스택을 만들어놓는다
top = -1

push(10,size)

# 이런 방식으로도 구현
top+= 1     
stack[top] = 20 # push(20)
```

### 스택의 pop 알고리즘

```py
def pop():
    if len(s) == 0:
        #underflow
        return
    else: 
        return s.pop()
```

```py
def pop():
    global top 
    if top == -1:
        print('underflow')
        return 0
    
    else: 
        top -= 1
        return stack[top + 1]    # 리턴 하고 아래껄 가리키게 할 수는 없으니깐 아래껄 가르키게 하고 이전 거를 pop

print(pop())

# 보통 이런 식으로 짠다
if top > -1: # pop()
    top -= 1
    print(stack[top+1])

# 아니면 이렇게

while top >=0:
    top -= 1
    pop = stack[top+1]
```


### 실습

```py

def push(n):
    top += 1
    if top == size:
        print('overflow!')
    
    else: 
        stack[top] = n

top = -1
stack = [0]*10 # 최대 10개 push

top += 1   # push(10)
stack[top] = 10

top += 1    #push (20)
stack[top] = 20

push(30)

#꺼내기

while top >= 0:
    top -= 1
    print(stack[top+1])
```

## 스택의 응용 1

- 1차원 배열을 사용하면 구현은 용이하지만 크기 변경이 어려움
- 이럴 땐 '동적 연결리스트'를 이용할 수 있는데, 파이썬은 내장 함수가 존재. 큐 할 때 자세하게


### 괄호 검사

- 괄호가 알맞게 짝지어서 순서대로 들어가있는지

  - 여는 괄호(()를 만나면 push, 닫는 괄호를 만나면 그걸 pop

(주의: 어차피 top이 바뀌면 해당 위치엔 push하면서 내용이 덮어써지므로 굳이 지우는 과정이 필요 없음)

  - 1)만약 꺼낼게 없거나, 2) 괄호 수식이 스택에 남아있으면 잘못된거  


```py
# (()))
```

## 스택의 응용 2

### Function Call

- 프로그램에서의 함수 호출과 복귀에 따른 수행순서를 관리 
  - 가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조
  - 스택을 이용해서 수행순서 관리 
>함수를 호출하면 메모리가 분리된다

## 재귀호출

- 필요한 함수가 자신과 같은 경우 자신을 다시 호출하는 구조
  -  서로 다른 함수를 호출한다 생각하면 오히려 이해가 쉽다 -> 호출될 때마다 분리된 고유의 메모리를 차지
- 함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식보다 재귀호출방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성 
  
- ex) factorial
- ex) 피보나치수

인자가 너무 많아지면 재귀가 어려워진다. 경계를 모르기 때문에 어려운 것. 팩토리얼이 쉬운 이유는 인자가 단 하나이고, 경계를 알기 때문에

보통 재귀는 현재위치와 목표를 같이 가져간다

```py
# 이게 기본 형태
def f(i,k): # i: 현재위치 k : 목표
    if i == k:
        pass
    
    else:
        f(i+1,k)

## 싹 다 출력하는 함수

def allprint(i,k):
    if i == k:
        return
    
    else:
        print(arr[i])
        f(i+1,k)

arr = [10,20,30]
N = len(arr)
f(0,N)

# 복사 작업
brr = []
def f(i,k): # i: 현재위치 k : 목표
    if i == k:
        print(brr)
    
    else:
        brr[i] = arr[i]
        f(i+1,k)
```

## Memoization

- 피보나치 call Tree를 확인하면 겹치는 부분이 있다 (fib(5)이후)

- 메모이제이션은 이전 계산 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하는거


how?

```py
def fibo1(n):
    global memo # 적어둘거
    if n>=2 and memo[n] == 0:
        memo[n] = fibo1(n-1) + fibo1(n-2)
    return memo[n] # 결과값을 저장해놓는거

memo = [0] * (n+1)
memo[0] = 0
memo[1] = 1
```

```py

def fib(n):
    global cnt # 호출 횟수
    cnt += 1 #호출 될 때마다 +1
    if n<2:
        return n
    else:
        return fibo(n-1) + fibo (n-2)

def fibo_memo(n):
    global cnt
    cnt += 1
    if n != 0 and memo[n] == 0:
        memo[n] = fibo_memo(n-1)+fibo_memo(n-2)

    return memo[n] 


 cnt = 0
 n = 7
 print(fibo(n),cnt) #41
cnt = 0
 memo = [0]*(n+1)
 memo[0] = 0
 memo[1] = 1   

 print(fibo_memo(n),cnt) #13 --> 횟수 차이가 크다

 ```


 # offline

 ## 종이 붙이기

 ```py
 '''
 1
 3
 5
 11
 21

 a(n) = a(n-2) * 2 + a(n-1)
 '''

 def cnt(n):
    if n % 10 == 0:
        if n == 10:
            return 1
        
        if n == 20:
            return 3
        
        else: # n>20 일 때, n-20에서의 경우의 수 2배와 n-10의 경우의 수의 합

        return cnt(n-10) + (2* (cnt(n-20)))

 ```


## 괄호 검색


```py
# SHB -> 짝이 안 맞는 경우엔 애초에 넣지 않는다.

T = int(input())

def check_1(string):
    stack = []

    try:
        for s in string:
            if s == '{' or s == '(':
                stack.append(s)
            if s == '}':
                k = stack.pop()
                if k == '{':
                    continue

                else:
                    return 0

            if s == ')':
                k = stack.pop()
                if k == '(':
                    continue

                else:
                    return 0
        if len(stack) != 0:
            return 0
        return 1
    except:
        return 0

for t in range(1,T+1):
    string = input()

    result = check_1(string)
    print(f'#{t} {result}')




```

```py

#강사님 -> 짝이 안 맞는 경우에도 일단 append 한다
T = int(input())

for t in range(1,T+1):
    text = input()
    stack = []

    for i in text:
        # 처음에 여는 괄호로 시작
        if i == '{' or i == '(':
            stack.append(i)
        
        # 닫는 괄호가 나온다 --> 짝이 맞는지 확인 -> 제거 -> pop

        elif stack and i == '}' and stack[-1] =='{': # if stack? stack에 항이 있냐
            stack.pop()

        elif stack and i == ')' and stack[-1] == '(':
            stack.pop()
        
        # 닫는 괄호인데 짝이 맞지 않는다. -> 스택에 추가
        elif i == '}' or i == ')':
            stack.apppend(i)
        
    if stack: # 스택에 남아있으면
        result = 0

    else:
        result = 1


```

### 자리의 합



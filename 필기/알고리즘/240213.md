# 5. 스택 2

- 계산기 1
- 계산기 2
- 백트래킹
- [참고]부분집합, 순열
- 분할정복

## 계산기 1

> 후기표현법 -> 한국어 어순과 비슷함

- 문자열로 된 계산식이 주어질 때, 스택을 이용하여 이 계산식의 값을 계산할 수 있다.
- 문자열 수식 계산의 일반적인 방법

  1. 중위 표기법의 수식을 후위 표기법으로 (3+4 -> 3 4 +)
     <스택이용1>
     1. 수식의 각 연산자에 대해서 우선순위에 따라 괄호를 사용하여 다시 표현
     2. 각 연산자를 그에 대응하는 오른쪽 괄호의 뒤로 이동시킨다
     3. 괄호를 제거한다.
  2. 후위 표기법의 수식을 스택을 이용하여 계산

  교재 보면서 추가 확인

  - 피연산자(숫자)는 그냥 출력, 연산자는 우선순위에 따라 스택에 저장, 이 때, 우선 순위에 따라 top을 변경
  - (는 안에 있으면 0, 밖에 있으면 3
  - )를 만나면 (를 만나기 전까지 모두 pop해서 출력
  - 우선순위가 같은 애를 만나면 우선순위가 낮은 애를 만나기까지 pop

### <연습문제1>

2+3\*4/5

234/\*+

## 계산기 2 - 실제 계산

- step2) 후위 표기법의 수식을 스택을 이용하여 계산

1. 피연산자를 만나면 스택에 push한다.
2. 연산자를 만나면 필요한 만큼의 피연산자를 스택에서 pop하여 연산하고, 연산ㄱㄹ과를 다시 스택에 push
3. 수식이 끝나면, 마지막으로 스택을 pop하여 출력

```py
'''
fx = (6+5*(2-8)/2)
'''


stack = [0] * 100
top = -1 # 스택 맨 위 인덱스.
# 이게 헷갈리면 그냥 append,pop 써도 됨

icp = {'(':3,'*':2,'/':2,'+':1,'-':1 } #스택 외부 우선순위

isp = {'(':0,'*':2,'/':2,'+':1,'-':1 }   #스택 내부 우선순위

fx = '(6+5*(2-8)/2)'
postfix = '' # 출력하는 거
for tk in fx:
   # 여는 괄호 push, 연산자가 top원소보다 우선 순위가 높으면 push
   if tk == '(' or (tk in '*/+-' and isp[stack[top]] < icp[tk]:
      top += 1 #push
      stack[top] = tk

   elif tk in '*/+-'and isp[stack[top]] >= icp[tk]:#연산자이고 top보다 우선순위가 높지 않으면
      # top 원소보다 우선순위가 나즐 때까지 pop
      while isp[stack[top]] >= icp[tk]:
         top -= 1 #pop
         postfix += stack[top+1]
      top += 1
      stack[top] = tk
   elif tk == ')': # 닫는 괄호면, 여는 괄호를 만날 때까지 pop
      while stack[top] != '(':
         top -= 1 #pop
         postfix += stack[top+1]
      top -= 1 # 여는 괄호 pop해서 버림
      stack[top + 1]

   else: #피연산자인 경우
      postfix += tk

print(postfix)
```

## 백트래킹 (스택활용)

> https://edder773.tistory.com/75

- 검색 중 하나 (완전 검색은 아니다 -> DFS와의 차이점 )
- 해를 찾는 도중에 '막히면'(즉 해가 아니면) _되돌아가서(주로 재귀에서 return 활용)_ 다시 해를 찾아 가는 기법
- 백트래킹 기법은 최적화 문제와 결정 문제를 해결 가능
- 결정문제: 문제의 조건을 만족하는 해가 존재하는지의 여부를 'yes' 또는 'no'로 답하는 문제
  - 미로 찾기 (가장 짧은 길이(최적화) 혹은 출구로 나갈 수 있는지(결정))
  - n-Queen
  - Map coloring
  - 부분 집합의 합(Subset Sum) 문제 등

### 미로 찾기

> 스택에 과정을 저장하고 일단 진행, 그러다 막히면 진행할 수 있는 상태로 되돌아가는것

< 백트래킹과 DFS의 차이>

- 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음-> 시도 횟수 줄임(가지치기)
- DFS는 모든 경로를 추적, 백트래킹은 조기에 차단
- 완전 검색이 아니므로 오류가 있을 수 있음

### 백트래킹을 이용한 알고리즘 절차

1. 상태 공간 트리의 깊이 우선 검색을 실시
2. 각 노드가 유망한지 점검
3. 유망하지 않으면, 부모 노드로 돌아가서 다시 검색(유망하지 않은 노드가 포함되면 걔는 더이상 고려 x != DFS)

```py
#nqueen
def checknode(v):#node
   if promising(v):
      if there is a solution at v:
         write the solution
      else:
         for u in each child of v:
            checknode(u)
```

### n-queen

(교재 무조건 확인)

### 상태 공간 트리

(교재 무조건 확인)

### 깊이우선검색 VS 백트래키

- 순수한 깊이 우선 탐색 : 155노드
- 백트래킹 : 27노드

### 부분집합

- 어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합을 powerset이라 하면, 구하고자 하는 어떤 집합의 원소가 n개일 때, 부분집합의 수는 2^n개(포함되거나 포함되지 않거나)

- 백트래킹으로 부분집합을 만드는 법?

```py
bit = [0,0,0,0] # 각 집합의 포함 여부 (0 or 1)

for i in range(2):
   bit[0] = i  #0번째 원소

   for j in range(2):
      bit[1] = j #1번째 원소

      for k in range(2):
         bit[2] = k

         for l in range(2):
            bit[3] = l
```

```py
def backtrack(a,k,input):
   global maxcandidates
   c = [0] * maxcandidates

   if k == input :
      process_solution(a,k) # 답이면 원하는 작업을 한다

   else:
      k += 1
      ncandidates = construct_cadidates(a,k,input,c) # 부분집합에 들어갈 후보
      for i in range(ncandidates):
         a[k] = c[i]
         backtrack(a,k,input)

```

```py
def f(i,k):
   if i == k:
      for j in range(k):
         if bit[j]: #1이면
            print(arr[j],end = ' ')
      print()
   else:
      # for j in range(2):
      #    bit[i] = j
      #    f(i+1,k)
      bit[i] = 1
      f(i+1,k)
      bit[i] = 0
      f(i+1,k)

N = 4
arr = [1,2,3,4]
bit  = [0] * N
f(0,N)
```

# Off-Line

## 후위표기법

```py
str_input = input()
stack = []

for char in str_input:
   if '0' <= char <= '9': # 아스키코드로 비교하면 숫자만 나옴
      stack.append(int(char))

   else:
      a = stack.pop() # 가장 마지막 요소
      b = stack.pop()

      if char == '+':
         stack.append(b+a)

      else:
         stack.append(b-a)

print(stack[-1])
```

## 반복 문자 지우기

```py
T = int(input())

for t in range(1,T+1):
   str_lst = list(input())
   stack = []

   for char in str_lst:
      # 만약 반복 문자라면 pop() ---> stack이 비어있지 않고, char이 마지막 문자와 같다면

      if stack and char == stack[-1]:
         stack.pop()
      else:
         stack.append(char)

   print(f'{t} {len(stack)}')
```

## 그래프경로(DFS)

```py
T = int(input())

def dfs(start,end):
   stack = []
   visited = [False]*(V+1)
   stack.append(start)

   while stack: # 스택이 비어있으면 반복문 종료
      now = stack.pop()
      visited[now] = True # 반복하면 True

      for next in range(1,V+1):
         if node[now][next] and not visited[next]: #방문하지 않았고, 연결되어 있다면
            stack.append(next)

   if visited[end]: #도착장소에 방문했다면
      return 1

   else:
      return 0

for t in range(1,T+1):
   V,E = map(int,input().split()) # V는 노드, E는 간섭의 갯수

   node = [[0 for _ in range(V+1)] for _ in range(V+1)]

   for _ in range(E):
      start,end = map(int,input().split())
      node[start][end] = 1 # 해당 인접 행렬에 1을 할당
   S,G = map(int,input().split())

   print(f'{t} {dfs(S,G)}')
```

```py
# SHB

T = int(input())

def bt(s,e):
    global S
    stack = []
    stack.append(s) # 시작 지역 저장
    while True:
        if arr[s] == [] or visited[s] ==1:
            s = stack.pop()
            if stack == []: # 더이상 돌아갈 곳이 없으면. 어차피 시작할 때 시작 지역이 stack에 연속으로 있어도 visited가 1이라 다 빠짐
                break
        else:
            visited[s] = 1 # 출근 도장
            for k in arr[s]:
                stack.append(s) # 이전 지역을 저장
                s = k
                if s == e: # 목적지에 도착하면
                    return 1

                if s == S: # 무한 루프 빠지면 ex) 1->5->7->3->1
                    break
                continue

    return 0


for t in range(1,T+1):
    V,E = map(int,input().split())

    arr = [[] for v in range(V+1)]

    for e in range(E): # arr에 노드와 경로 저장
        a,b = map(int,input().split())
        arr[a].append(b)

    S,G = map(int,input().split()) # 시작과 끝

    visited = [0] * (V + 1) # 출근도장 제작

    result = bt(S,G)

    print(f'#{t} {result}')
```

# 백트래킹

: 가능한 모든 경우의 수를 탐색하면서, 조건에 맞지 않는 경우 탐색을 중단하고 되돌아가는(backtrack) 방식

> why? 가능한 모든 경우의 수 중 특정 조건을 만족하는 경우에만 찾아내는 방식

extra) 가능한 모든 경로는 탐색하면서, 이미 시도했던 경로는 다시 탐색하지 않는 것 => 가지치기

방법? return, 혹은 방문 표시를 다시 0으로 되돌리기

> shb 방문표시는 내가 썼는지 확인이 필요할 경우

## 10을 만들자(low)

숫자를 더해서 10이 되는 경우만 체크. 그럼 언제 백트래킹 해야하나? _합이 10을 초과하는 경우_

```py
cnt = 0

def func(n,level=0,sum_v=0):
   global cnt

   if sum_v > 10: #백트래킹, 합이 10을 초과는 경우 더이상 진행하지 않고 이전 노드로 돌아가는 것
      return

   if level == n: # 모든 level을 탐색했을 때, 원하는 만큼 더했을 때. (n=3 이면 1+1+8같이)
      if sum_v == 10:
         cnt += 1
      return

   for i in range(1,10):
      func(n,level+1,sum_v+i)

n = int(input())
func(n)
print(cnt)
```

```py
# shb
N = int(input())
rst = 0
def ten(N,cnt=0,ans = 0):
    # global ans
    global rst
    if cnt == N and ans == 10:
        rst += 1
        # ans -= k
        return
    else:
        if cnt >= N or ans > 10:
            # ans -= k
            return
        else:
            for i in range(1,10):
                # k = i
                ten(N,cnt+1,ans+i)

ten(N)
print(rst)
```

## 레드마운틴 - 가지치기 예시

1. 장애물이 있는 경우
2. 이미 방문한 경우 -> 가지치기

```py
n = int(input())

arr = [list(map(int,input().split())) for _ in range(n)]
dir = [(-1,0),(1,0),(0,-1),(0,1)]
used = [[0 for _ in range(n)] for _ in range(n)] # 각 칸의 방문 여부 체크

def red(dy,dx):
   if dy == n - 1 and dx == n-1: # 목적지 도착 시
      return 1

   for d in dir:
      ny,nx = dy + d[0], dx + d[1]

      if not(0<=ny<n and 0<=nx<n): # 1.맵의 범위 벗어났을 때
         continue

      if arr[ny][nx] == 1: # 2.장애물 만났을 때
         continue

      if used[ny][nx] == 1: # 3. 이미 방문한칸일 때 다른 방향 탐색 -> 가지치기
         continue

      used[ny][nx] = 1 # 현재 칸 방문 표시

      ret = red(ny,nx) #다음 칸 할당

      if ret == 1: #결국엔 목적지 도착해서 1을 return 받았을 때
         return 1 # 부모 노드에도 쭉 1을 올려라

      used[ny][nx] = 0 #백트래킹, 가지치기 : 이 경로가 해결책이 아니라면, 방문표시 되돌리기... 이건 왜???

   return 0 # 만약 for문, 재귀까지 다 돌았는데도 목적지에 도착하지 않았다면 0을 return 해라

used[0][0] = 1 # 시작점 방문

print(red(0,0))
```

```py
#shb -> 얘는 방문기록 리셋이 없다.

n = int(input())
arr = [list(map(int,input().split())) for _ in range(n)]
e = (n-1,n-1)
s = 0,0
visited = [[0 for _ in range(n)] for _ in range(n)]
dir = [(0,1),(0,-1),(1,0),(-1,0)]

def bt(s,e):
    i = s[0]
    j = s[1]
    ei, ej = e
    visited[i][j] = 1

    for k in dir:
        ni = i + k[0]
        nj = j + k[1]
        if not(0<=ni<n and 0<=nj<n):
            continue

        elif arr[ni][nj] == 1:
            continue

        elif visited[ni][nj] == 1:
            continue

        else:
            s = ni,nj
            bt(s,e)


    if visited[ei][ej] == 1:
        return 1

    else:
        return 0


print(bt(s,e))

```

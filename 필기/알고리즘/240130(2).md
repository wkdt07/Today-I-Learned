카운트 배열/누적값/정렬

# 5. 카운팅 정렬

## 1) 카운팅 정렬
항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 *선형 시간에 정렬*하는 효율적인 알고리즘

- 제한사항
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능, 
  - ex) 2 2 1 3 5 2, 각 숫자들이 몇 갠지 알고 싶다? 0 1 2 1 0 1... 식으로 각 인덱스에 해당 숫자가 몇 개인지 저장 => 항목이 인덱스가 되어야 함
  - 카운트들을 위한 충분한 공간을 할당하려면 *집합 내의 가장 큰 정수를 알아야 함*( 그 가장 큰 정수가 카운트 배열의 마지막 인덱스)
- 시간 복잡도
  - O(n+k) : n은 리스트 길이, k는 정수의 최댓값
## 2) 카운팅 정렬 과정

1) 이걸 완벽히 이해해야함. 카운팅 말고도 자주 쓰임
   - Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장
     - counts = [0]*(k+1) : k는 최대 정수
     - +) N개 : [0]xN , 마지막 자리 N : [0]x(N+1)
     - for x in DATA: \n counts[x] += 1

2) 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다. (누적 개수 구하기)
     ```sudo
    for i : 1->k
        counts[i]<-counts[i-1]+counts[i]
    ```

3) counts[k]을 감소시키고 인덱스가 counts[k]+1인 자리에 Temp에 k을 삽입한다

```python
N = 6
K = 9 #0~K
data = [7,2,4,5,1,3] # 0~9, K = 9
counts = [0]*(K+1)
temp =[0]*N # 정렬된 배열 저장소
# counts 배열에 기록하기
for x in data:
    counts[x]+=1
#counts 누적합 구하기
for i in range(1,K+1):
    counts[i] += counts[i-1] + counts[i]

#  data의 마지막 원소부터 정렬하기
for i in range(N-1,-1,-1): # N-1 -> 0번 인덱스(역순으로 해야 같은 값이 나왔을 때 리스트를 관리할 수 있음, 같은 숫자는 거꾸로 들어감. 좌표 같은 거면 문제가 생김)
    counts[data[i]] -= 1 #개수를 인덱스로 변환(남은 개수 계산)
    temp[counts[data[i]]] =data[i]
print(*temp)

```
## 3) 카운팅 정렬 알고리즘

# 정렬 알고리즘 비교

# 5. 완전 검색

## 1) Baby-gin game
- 설명 
  - 0~9 사이 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호가 run, 3장의 카드가 동일한게 triple
  - run과 triplet으로만 구성된 경우가 baby-gin
- 여부를 어떻게 찾을것인가?
## 2) 완전 검색(Exaustive Search)
- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

- 모든 경우의 수를 테스트한 후, 최종 해법을 도출
- 일반적으로 경우의 수가 상대적으로 작을 때 유용
## 3) 완전 검색으로 시작하라

- 수행속도 느리지만 해답을 엥간하면 찾음
- A형의 목표가 여기까지

## 4) 완전 검색을 활용한 Baby-gin 접근

- 고려할 수 있는 모든 경우의 수 생성
  - 6개의 숫자로 모두 만들 수 있는 나열(중복 포함) :6!

## 5) 순열을 어떻게 생성할 것인가
- 서로 다른 것들 중 몇개를 뽑아서 한 줄로 나열하는 것

## 6) 단순하게 순열을 생성하는 방법
예) {1,2,3}을 포함하는 모든 순열을 생성하는 함수

```python
for i1 in range(1,4):
    for i2 in range(1,4):
        if i2 != i1: #겹치는건 제외(1,1,?) (2,2,?)
            for i3 im range(1,3):
                if i3 != amd i3 != i2:
                    print(i1,i2,i3)

# shb 나열 숫자만큼 for문이 생긴다.
```

# 탐욕(Greedy) 알고리즘 (<->완전검색)
- 최적해를 구하는 데 사용되는 *근시안적인 방법*
- 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달(전체 중 하나를 선택한 이후)
- 지역적으로는 최적이지만, 전체적으로 이게 최적이라는 보장은 없다 => 모든 상황에 적용 가능한건 아니다
- 머릿속에 떠오르는 생각을 검증 없이 구현하면 대부분 그리디
## 1) 탐욕 알고리즘의 동작 과정
1) 해 선택 : 현재 상태에서 부분 문젱의 최적 해를 구한 뒤, 이를 부분해 집합에 추가
2) 실행 가능성 검사
3) 해 검사

> 시작 방식을 바꾸면 안됨, 그러면 완전검색이 되어버림
## 2) 탐욕 알고리즘의 예
1) 거스름돈 줄이기(어떻게 하면 주는 지폐와 동전의 개수 최소한으로?)

2) Baby-gin : counts 배열을 통해 run과 triplet 확인,찾으면 카운트 지운다
   - 333456이면? run과 triplet 중 뭐를 먼저 판단? triplet부터 -> 그리디는이걸 바꾸면 안됨. 
   - 123456이면? 어차피 왼쪽부터 찾거나 오른쪽 부터 찾음
## 3) 탐욕 알고리즘 풀이

## 4) 구현 예

```python
num = 456789 #BabyGin 확인할 6자리수
c = [0]*12 # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트
#0~9이지만 2개를 추가해서 더 쉽게 만들 수 있도록 # run에서 오류 피하기 위해

for i in range(6):
    c[num%10]+=1 #나머지를 이용
    num//=10   # 붙어있는 숫자를 각각 자르는 방법

# 만약 자리수가 정해져 있지 않다면 while num>0 사용

i = 0 #내가 run,triplet 인지 아닌지 확인하는 자리

tri = run = 0

while i<10:  # i는 9까지만 감
    if c[i]>=3: # triplet 조사 및, 맞으면 삭제
        c[i] -= 3
        tri += 1
        continue # 한 번 더 일 수도 있으니까 다시 해당 i 에서 triplet 검사
    if c[i]>= 1 and c[i+1]>=1 and c[i+2]>=1 : #run 조사 후 삭제. 여기서 인덱스 오류 안 나려고 c를 12칸 만들어놓은거, i=9에거 triplet 나올 수 있으니깐 i=9도 해야 되기도 함
        # 만약 그게 싫으면 이 if 문에다가 i<=7 쓰면 되긴 함
        c[i]-=1
        c[i+1]-=1
        c[i+2]-=1
        run += 1
        continue
    i += 1
if run + tri ==2 :
    print('Baby Gin')
else: 
    print('Lose')
```


## 5) 자주 실수하는 오답
정렬해서 자르는거? 

123123일 경우 112233이 되서 오히려 못 찾을 수 있음 -> 얘도 그리디이긴 함. But 그리디는 오류가 날 수 있음


# Off-Line

## 1. 버블 정렬

: 인접한 두 요소를 비교하여 큰 값을 오른쪽으로 이동시키는 과정을 반복

```python
# 첫 번째 for 문 : 배열의 모든 요소 순회

numbers = [63,31,27,11,29]


def bubble(arr)
    for i in range(len(arr)):
        # 두 번째 for 문 : 배열의 끝에서 *정렬된 부분을 제외*하고 순회 
        for j in range(len(arr)-i-1):
            # 인접한 두 요소를 비교하여 위치 바꾸기
            if arr[j]>arr[j+1]:
                arr[j],arr[j+1] = arr[j+1],arr[j]
    #return 없어도 arr 가 없어서 상관 없음


```
## 2. 카운팅 정렬 : 정수를 정렬하는 알고리즘, 각 숫자의 개수를 세어서 정렬

```python
list1 = [1,4,1,2,7,5,2]

def counting(arr):
    #배열의 최댓값
    max_v = max(arr)
    #각 숫자의 등장 횟수 초기화
    cnt_arr = [0]*(max_v+1) # max_v의 +1만큼 배열 초기화.
    #cnt_arr에 각 숫자의 횟수를 세어서 저장
    for num in arr:
        cnt_arr[num] += 1 # 위치(인덱스)는 해당 값으로

    sorted_arr = []
    # cnt_arr를 순회하여 각 숫자에 해당 숫자의 등장 횟수만큼 sorted_arr에 추가
    for i, count in enumerate(cnt_arr): # i: 해당 값, count : 횟수
        sorted_arr.extend([i]*count) # i=n 이면 그게 들어가 있는 count만큼 sorted_arr에 i=0부터 차례대로 저장
    return sorted_arr

sorted_list = counting(list1)
print(counting(list1))
```

## 3. 완전검색

- 순열: 주어진 항목들로 만들 수 있는 모든 가능한 순서(경우의 수)

- how? 
  - for문
  - itertools 모듈

```python
import itertools
arr = [1,2,3,4]
result = list(itertools.permutations(arr))
print(len(result)) #24
print(result) #순열 값들 나옴
```


## 4. 탐욕 알고리즘

각 단계에서 가장 최선의 선택을 하는 방법

거스름돈 문제? 어떻게 해야 가장 적은 수의 동전으로 거스름돈을 받을 수 있을까?

--> 최선의 선택: *가장 큰 단위의 동전부터 사용하는 것*

### 실습

#### 동전의 종류가 100원, 50원, 10원, 거스름돈이 380원이라면

동전의 단위와 개수를 출력, dict로


```python
#shb
def change(n):
    arr = [100,50,10]
    cnt = [0]*len(arr)
    dic = {}
    for i in range(len(arr)):
        if n // arr[i] != 0:
            cnt[i] = (n//arr[i])
            n = n % arr[i]
        dic.setdefault(arr[i], cnt[i]) #이거 위치에서 해맸음
    return dic

print(change(380))

```

```python
#강사님
def greedy(money,coins): #money : 거스름돈, coins : 동전단위
    coins.sort(reverse = True) #내림차순 정렬
    change = {coin:0 for coin in coins} # dict도 리스트 컴프리헨션처럼 가능

    for coin in coins:
        #거슬러 줄 수 있을 동안 반복
        while money >= coin :
            money -= coin # 거슬러 주는 동안 거스름돈에서 차감
            change[coin] += 1 #해당 동전의 value 개수를 1씩 증가
    return change

result = greedy(380,[100,50,10])
print(result)
```

## 전기버스 - 실패

```python

## shb
T = int(input())

for t in range(1,T+1):
    k,n,m = map(int,input().split())
    station = [0]*(n+1)
    ch_idx = list(map(int,input().split()))
    for i in ch_idx:
        station[i] = k
    fuel = k # 연료통
    hllst = []
    for i in range(0,len(ch_idx)-1):
        howlong = ch_idx[i+1]-ch_idx[i]
        hllst.append(howlong)
    hllst.append(n-max(ch_idx))

    max_l = max(hllst)
    cnt = 0
    for i in range(n):
        fuel -= 1

        if fuel == 0:
            print(f'#{t} 0')
            break

        for j in hllst:
            if fuel < j:
                fuel += k
                if station[i] != 0:
                    cnt += 1

    print(f'#{t} {cnt}')
```


```python
## 강사님
T = int(input())

for t in range(1,T+1):
    k,n,m = map(int,input().split())
    arr = list(map(int,input().split()))
    curr , cnt = 0,0 # curr : 현재 위치 , cnt : 충전횟수
    while curr != n: # 종점에 도착할 때까지 반복
        if n <= curr + k: #curr + k : 한 번 충전으로 갈 수 있는 거리, n: 종점 까지의 거리
            curr = n #그냥 종점 도착했다 쳐도 됨. 어차피 갈 수 있으니깐
            break


        for i in range(len(arr)-1,-1,-1): #충전소 뒤에서부터 순회 why? 현재위치(curr)에서 더 적은 횟수로 가장 가까운 충저노를 먼저 찾을 수 있기 때문
            if arr[i] <= curr+k: #리스트 arr의 값(충전소 위치)이 한 번 충전으로 갈 수 있는 거리 이내에 있다면
                cnt += 1 #충전 횟수 증가
                curr = arr[i] #현재 위치를 충전소 위치로 변경
                arr = arr[i+1:] # 해당 충전소 이후의 정류장만 남기기
                break

            if i == 0: # 충전소를 찾지 못했다면
                cnt = 0
                curr = n #현재 위치를 종점으로

    print(f'#{t} {cnt}')
```

## 숫자카드

```python
T = int(input())

for t in range(1,T+1):
    N = int(input())
    string = input()
    # num = int(input())
    num_lst = []
    # while num%10 != 0:
    #     k = num % 10
    #     num_lst.append(k)
    #     num = num//10 이러면 맨 앞 자리가 0일 때는 판단 불가


    for i in string:
        num_lst.append(int(i))

    cnt_lst = [0] * 10

    for num in num_lst:
        for i in range(len(cnt_lst)):
            if num == i:
                cnt_lst[i] += 1


    cnt_lst.reverse()
    max_c = max(cnt_lst)
    max_v = 9 -cnt_lst.index(max_c)
    print(f'#{t} {max_v} {max_c}')
```

## 5. 방향배열


### 폭탄배열

```python
## shb
'''
1 1
3 3
'''
a = list(list('_' for i in range(5))for _ in range(4))

x = [-1,1,0]
y = [-1,1,0]

for t in range(2):
    i, j = map(int, input().split())
    for dx in x:
        for dy in y:
            try:
                if dx == 0 and dy == 0:
                    break #이건 break 해야 아래로 안 감
                a[i+dx][j+dy] = '#'
            except:
                pass

for arr in a:
    print(*arr)
```

```python
# 내 방식 버리고 이대로 풀어라


arr = [['_']*5 for _ in range(4)]

# 1)
for _ in range(2): #입력 받는 수가 2개니깐
    y,x = map(int,input().split())
    dy = [-1,-1,-1,0,1,1,1,0] #y 방향의 방향배열
    dx = [-1,0,1,1,1,0,-1,-1] #x 방향의 방향배열
    # direction = [(-1,-1),(-1,0).....]
    for i in range(8) #상하좌우+대각선4
        ny = dy[i] + y #방향 + 현재y
        nx = dx[i] + x
        if ny <0 or nx < 0 or ny >3 or nx >4:
            continue #예외 상황에선 다음 반복으로 #continue 안 쓰면 and로
        arr[ny][nx] = '#'

for row in arr:
    print(*arr)


#2) direction = [(-1,-1),(-1,0).....] 쓴다면?

for _ in range(2):
    y,x = map(int,input().split())
    direction = [(-1,-1),(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1)(0,-1)]
    for dy,dx in direction: # 튜플 - 튜플 형태
        ny = y + dy
        nx = x + dx
        .
        .
        .


# 3) continue 안 쓰고?

if 0<=ny<4 and 0<=nx<4: #이걸 or 들어간 자리에 푼다
```




# +)
## Adv(A형) : 완전 탐색을 기반으로 어느 상황에서든 '에러없이' 돌아가는 프로그램을 작성할 수 있는가?

BFS : 너비 우선 탐색, '최대한 적은 노드'를 돌려서 가는 경로 --> 퍼져나가는 형태를 구현하는 경우

DFS: 깊이 우선 탐색, '모든 경로'로 돌려보는게 가능 --> 모든 경우의 수를 확인할 때
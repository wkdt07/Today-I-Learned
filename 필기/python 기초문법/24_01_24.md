# 0. Index
오늘 초반부가 추상적이라 이해가 안 되는 부분이 많을 수 있음. 뒷부분에서 해결

- 객체 지향 프로그래밍
- 객체
- 클래스
- 메서드

# 1. 객체 지향 프로그래밍

## 1) 절차 지향 프로그래밍(Procedural Programming)

프로그램을 '데이터'와 '절차'로 구성하는 방식의 프로그래밍 *패러다임*
 : '이런 식으로 프로그램을 작성하자' 라는 흐름

절차 -> 순서가 중요하다.

### 특징
- 데이터와 해당 데이터를 처리하는 함수가 분리되어 있으면 함수 호출의 흐름이 중요.
- 코드의 *순차적인 흐름*과 *함수 호출*에 의해 프로그램이 진행 (순서가 중요)

데이터의 재사용 여부보단 함수가 실행될 수 있냐가 더 중요

### 단점-소프트웨어 위기 

- 하드웨어의 발전으로 컴퓨터 계산용량과 문제의 복잡성이 급격히 증가하는데 이를 절차지향 계열의 sw의 효율이 따라가질 못함. 
  
why? 함수 하나가 어긋나면 연결된 모든 프로그램이 다운된다. => 절차 중간이 무너지면 프로그램이 무너지는 현상이 발생 -> 객체 지향 프로그래밍의 등장

## 2) 객체 지향 프로그래밍(Object Oriendted Programming)

데이터와 해당 데이터를 조작하는 메서드(함수)를 하나의 객체로 묶어, 관리하는 방식의 프로그래밍 패러다임

PP는 함수와 데이터를 별개로 보고, 이 중 함수를 중요하게 봤음. 근데 OOP는 데이터와 함수를 하나로 묶어서(클래스) 관리. 

### 절차 지향 vs 객체 지향

절차 지향 > 전사가 공격을 하려면 공격이란 함수가 필요하고, 마법사도 같은 함수를 사용

공격을 한다(전사가) -> 함수가 우선

객체지향 > 클래스라는 개념이 발생. 클래스(캐릭터, 전사, 마법사) 전사와 마법사라는 클래스는 캐릭터라는 클래스에 의해 만들어짐. 상하관계, 포함관계가 적용된다.(상위 클래스가 존재)

전사가 베기를 한다. -> 클래스가 먼저

 -> 절차지향은 공격, 수비라는 함수가 중요하게 여겨짐. 
객체 지향은 데이터와 함수를 클래스 안에 넣어둠. 

<절차 지향 객체 지향 비교>

졸았음. 수업 다시 들어라.

## 3) 객체

### 클래스

파이썬에서 타입을 표현하는 방법

type() >> < class ' '>

>객체를 생성하기 위한 *설계도*

> 데이터와 기능(함수)을 함께 묶는 *방법*을 제공


### 객체

> 클래스에서 정의한 것을 토대로 *메모리에 할당된 것*, '속성'과 '행동'으로 구성된 모든 것
> => 파이썬의 모든 것이 객체
>
객체 예시?

가수라는 객체가 있다 치자. 3개의 속성과 3개의 행동을 가짐.

-> 속성(정보) : 변수

-> 행동(동작) : 메서드

### <클래스와 객체>

가수(클래스) : 설계도, 일종의 청사진

-> 이 설계도대로 '객체'를 찍어내는 것 (아이유, BTS 등등)

- 클래스로 만든 객체를 *인스턴스*라고도 함.
    - 아이유는 객체다 o
    - 아이유는 인스턴스다 x
    - 아이유는 '가수'의 인스턴스다 o


- 클래스는 객체다? 객체는 파이썬의 모든 것이자 메모리에 저장되는 것. 그래서 클래스 자체도 객체

### (졸았음)

변수 name의 타입은 str 클래스다.
- - 변수 name은 *str 클래스의 인스턴스이다*
- - 우리가 사용해왔던 *데이터 타입은 사실 모두 클래스*였다.


### < 인스턴스와 메서드>

class 안에 존재하는 함수가 메서드.

그래서 type별로 메서드가 달랐던 것. 그 타입도 클래스의 인스턴스니깐.

ex)

>'hello'.upper()

클래스 str 안의 함수 upper()를 호출

>객체.행동()

>인스턴스.메서드()

#### *하나의 객체는 특정 타입(클래스)의 인스턴스 이다.*

#### <객체의 특징>

- 타입 : 어떤 연산자와 조작이 가능한가?, *모든 타입은 특정 클래스의 인스턴스이다.*
- (클래스 안의)속성(attribute): 어떤 상태(데이터)를 가지는가?
- 조작법(method) : 어떤 행위(함수)를 할 수 있는가?
  
 


## 3) 클래스

파이썬에서 타입을 표현하는 방법
- 객체를 생성하기 위한 설계도
- 데이터(속성)와 기능(메서드)을 함께 묶는 방법을 제공


### <클래스 구조>

```python
###클래스 정의
class Person: 
    pass

# 대문자로 시작 -> PaskalCase(=Camel Case) <-> sneak case: 우리가 지금까지 쓰던 소문자 시작, 물론 sneak case 써도 오류는 아님. 구분용

# 소괄호가 없음


### 인스턴스 생성
iu = Person()

#OOP를 안 배웠으면 iu는 단순 변수지만, 이제 저건 인스턴스라는걸 알 수 있음

###메서드 호출
iu.method()

### 속성(변수) 접근
iu.attribute()

클래스 -> 병사를 생산. 이 병사들이 메서드를 활용하고 속성값을 생성. 

이를 통해서 재생산 등에서 효율이 커짐. 
```


```python
class Person:
    # 속성(=변수)
    blood_color = 'red' #클래스 변수, 이게 속성 역할


    #메서드 
    def __init__(self,name):
        self.name = name #self의 속성 name에 name을 할당
        # 이게 인스턴스 변수
    
    def singing(self):
        return f'{self,name}가 노래합니다.' #메서드
    


# 인스턴스 생성

singer1 = Person('hi')

#졸았음
```

### <클래스 기본활용>
- 생성자 함수 (__init__())
  - 객체를 생성할 때 (인스턴스가 만들어 질 때) 자동으로 호출되는 특별한 메서드
  - __init__이라는 이름의 메서드로 정의되며, 객체의 초기화를 담당
  - 생성자 함수를 통해 인스턴스를 생성하고, *필요한 초기값을 설정*

- 인스턴스 변수
   - 인스턴스(객체)마다 '별도로' 유지되는 변수 -> 다른 클래스의 인스턴스와 변수 겹쳐도 됨
   - 인스턴스가 생성될 때마다 초기화됨.


- 클래스 변수
  - 클래스 내부에 선언된 변수
  - 클래스로 생성된 모든 인스턴스들이 공유하는 변수


- 인스턴스 메서드
  - 각각의 인스턴스에서 호출할 수 있는 메서드
  - 인스턴스 변수에 접근하고 수정하는 등의 *작업을 수행*->동작
  - 인스턴스가 쓰기 때문에 '인스턴스 메서드', 우리가 지금까지 쓰던 .append() 같은거.

### <인스턴스와 클래스 간의 이름 공간(namespace)>

- 클래스를 정의하면, 클래스와 해당하는 이름 공간 생성
- 인스턴스를 만들면, 인스턴스 객체가 생성되고 *독립적인* 이름 공간 생성
- 인스턴스에서 특정 속성에 접근하면, 인스턴스 - > 클래스 순으로 탐색(LEGB와 비슷)


인스턴스별로 아예 다른 이름 공간이 init에 의해 생성됨



*==================== 너무 졸아서 수업 다시 들어아 함======*


```python
class Person:
    name = 'unknown'
    # 생성자 함수가 없음
    def talk(self):
        print(self.name)

p1 = Person()
p1.talk()
# 현재 인스턴스 변수 name이 없어서 
#클래스에서 찾아서 unknown이 나옴

p2 = Person()
p2.name = 'kim' # 이제 p2한테 인스턴스 변수가 할당됨
p2.talk() # 'kim'

print(Person.name) #unknown
print(p1.name) #얘는 본인게 없어서 class의 변수인 unknown이 출력
print(p2.name) # 'kim'

p2.ssafy = 11
print(p2.ssafy) #p2에 또다시 새로운 인스턴스 이름공간(ssafy)을 만들어서 할당한거임
#독립적인 거임. name 안 맞춰도 됨
```

#### 독립적인 이름공간을 가지는 이점

- 각 인스턴스는 독립적인 메모리 공간을 가짐(클래스와 그로 인한 인스턴스도 독립되어 있다고 봐야함.) 클래스와 다른 인스턴스 간에는 서로의 데이터나 상태에 직접적인 접근이 불가능

- 클래스와 인스턴스를 모듈화하고 각각의 객체가 독립적으로 동작하도록 보장하는게 OOP의 최대특징

- 이로 인해 클래스와 인스턴스는 다른 객체들과의 상호작용에서 서로 충돌이나 영향을 주지 않으면서 독립적으로 동작할 수 있음 <-> PP

# 4. 인스턴스 변수와 클래스 변수

## 1) 클래스 변수 활용

- 가수가 몇 명인지 확인하고 싶다면? 
    - 인스턴스가 생성될 때마다 클래스 변수가 늘어나도록 설정할 수 있음
  ```python
  class Person:
    count = 0

    def __init__(self,name):
        self.name = name
        Person.count += 1 #인스턴스가 생성될 때마다 클래스 변수 count가 1씩 증가한다,.
  
  ```

## 2) 클래스 변수와 인스턴스 변수

클래스 변수를 변경할 때는 항상 *클래스.클래스변수* 형식으로 변경


```python
class Circle():
    pi = 3.14
    def __init__(self,r):
        self.r = r

c1 = Circle(5) #r =5
c1 = Circle(10) #r = 10

c2.pi = 5 
#*인스턴스 내에 할당된 인스턴스 변수 pi=3.14를 5로 재할당

print(Circle.pi) #3.14
print(c1.pi) #3.14
print(c2.pi) #5

```


# 5. 메서드

## 1) 메서드 종류

- 인스턴스 메서드 -> 우리가 지금까지 쓰던거. 인스턴스가 쓰기 때문에 인스턴스 메서드
- 클래스 메서드
- 정적 메서드

-> 누가 쓰는지에 따라 나눠놓은것

### <인스턴스 메서드>
클래스로부터 생성된 각 인스턴스에서 호출할 수 있는 메서드
- 인스턴스의 상태를 조작하거나 동작을 수행

#### <인스턴스 메서드 구조>
- 클래스 내부에 정의되는 메서드의 기본
- ***반드시*** 첫 번째 매개변수로 *인스턴스 자신(self)을 받음

```python
class MyClass:
    def instance_method(self,arg1,...) #반드시 인스턴스 자기자신(self)이 첫 번째 매개변수로 들어가야 함
    pass
```

why?

#### self 동작 원리

- upper 메서드를 사용해 문자열 'hello'를 대문자로 변경하기
> 'hello'.upper()
- 하지만 실제 파이썬 내부 동작은 다음과 같이 이루어진다.
> str.upper('hello')

이래서 구조상 첫 번째 매개변수가 자기 자신이 아니면 불가능함.

> *** 인스턴스 메서드의 첫 번째 매개변수가 반드시 자기자신이 들어가야 동작한다.


그럼 왜 str.upper('hello')를 안 쓰냐?

객체지향방식의 메서드로 호출하는 표현이다.(단축형 호출) -> 그냥 어순이 바뀌었다 생각해라. 메서드보다 객체가 더 중요해져서

- 'hello'라는 문자열 객체가 단순히 어딘가의 함수로 들어가는 인자가 아닌 객체 스스로 메서드를 호출하여 코드를 동작하는 객체 지향적 표현이다.

#### +) def 할 때 self를 ssafy라 바꿔도 되나? 
가능함. 

why? 함수 정의할 때 매개변수 이름을 뭘로 하든 맨 처음에 들어오는게 객체라는 점은 차이가 없음. ssafy = '객체 이름'이라는 할당이 지나감. 근데 절대 이렇게 안 하고, 그냥 *self* 사용.

맨 처음에 들어오는게 자기 자신이라는게 가장 중요

### <생성자 메서드(Constructor method)>

인스턴스 객체가 생성될 떄 *자동으로* 호출되는 메서드

양 옆에 언더바 2개 써서 표현

```python
class Person:
    def __init__(self,name): #얘도 자기 자신을 매개변수로 삼음
        print(f'인스턴스가 생성되었습니다.{name}')


preson1 = Person('지민') # 인스턴스가 생성되었습니다. 지민

```


### <클래스 메서드>
클래스가 호출하는 메서드

클래스 변수를 조작하거나 클래스 레벨의 동작을 수행

#### <클래스 메서드 구조 >

- 데코레이터 (@classmethod) 를 사용하여 정의

- 호출 시, 첫번째 인자로 호출하는 클래스(cls)가 전달됨

```python
class MyClass:

    @classmethod

    def class_method(cls,arg1,...): #여기 있는 cls도 바꿔도 동작은 함. but 바꾸지 마라
        pass
```

이걸 왜 쓰냐? 


# ==================졸았음
# ==========================


### <스태틱(정적)메서드>

클래스와 인스턴스와 상관없이 독립적으로 동작하는 메서드

- 주로 클래스와 관련이 있지만, 인스턴스와 상호작용이 필요하지 않은 경우에 사용
=========================================================================================================
=======================================================

#### 스태틱 메서드 구조

- @staticmethod 데코레이터 사용하여 정의
- 호출 시 필수적으로 작성해야 할 매개변수가 없음 != 다른 메서드
- 즉, 객체 상태나 클래스 상태를 수정할 수 없으며, 단지 기능(행동)만을 위해 정의된 함수.
- 클래스가 호출한다 

클래스 - 클래스메서드와 스태틱 메서드 2개를 호출

인스턴스 -  인스턴스 메서드 하나만 호출
```python

```


# 5. 메서드 정리

## 1) 메서드 정리

- 인스턴스 메서드 -> self
    - 인스턴스의 상태를 변경하거나, 해당 인스턴스의 특정 동작을 수행

- 클래스 메서드->데코레이터, cls
   - 인스턴스의 상태에 의존하지 않는 기능을 정의

.

.

.

.

.

### <각자의 역할>


### <메서드 정리 예시>

```python
class MyClass:
    def instance_method(self):
        return 'instance_method' , cls

    @classmethod
    def class_method(self):
        return 'class method'

    @staticmethod
    def static_method(self):
        return 'static method'

instance = MyClass() #클래스

print(MyClass.instance_method(instance)) #이게 왜 되지? 클래스는 인스턴스 메서드를 못 쓰는게 아닌가? 아니다. 사용해야 할 것과 사용할 수 있는것은 다른거임

''' 이거랑 비슷한거임

str.upper('hello world')

오류가 나진 않지만 헷갈리지 않게 그냥 쓰지 마라라는거
'''

#인스턴스가 전부 다 호출해보기
print(instance.instance_method())
print(instance.class_method())
print(instance.static_method())

'''
얘도 전부 가능.
why? 인스턴스는 본인한테 해당 메서드가 없으면 위로 올라가서 클래스 내에서 찾아낸다.

구조상 가능하긴 하지만 엥간하면 이렇게 하지마라.
'''
```

### 할 수 있다 != 써도 된다

각자의 메서드는 oop 패러다임에 따라 명확한 목적에 따라 설계된 것이기 때문에 클래스와 인스턴스 각각 올바른 메서드만 사용하도록 해야한다.

< 인스턴스가 할 수 있는 것>
인스턴스는 모든 메서드를 호출 할 수 있음

But, 인스턴스는 인스턴스 매서드만 쓰도록 하자.

# 5. 참고

## 매직 메서드

- 인스턴스 메서드
- 특정 상황에 자동으로 호출되는 메서드
- Double underscore가 있는 메서드는 특수한 동작을 위해 만들어진 메서드
- 스페셜 메서드 혹은 매직 메서드라고 불림
- 인스턴스 메서드? __magic_method__(*self*,...)
- 우리가 직접적으로 사용하진 x

#### __init__(self, ...) -> 클래스 만들 때 자동으로 호출

#### __str__(self,...) -> print 할 때 자동으로 호출


## 데코레이터

다른 함수의 코드를 유지한 채로 수정하거나 확장하기 위해 사용되는 *함수*

def my_decorator(*func*)
...

사용)

@my_decorator

def my_function():

이러면 my_decorator의 인자로 my_function()이 들어감


#### 왜 사용? 수업 다시 확인


### 절차 지향과 객체 지향은 반대되는 개념이 아니다!



# Off-Line


## 1. 절차 지향 프로그래밍 언어 : c언어, 포트란 등
: *함수를 연속으로 구성*하는 프로그래밍 패러다임

```c
#include<studio,h>
int add(int a, ) 
int main(){
    int num1 = 10;
    int num2 = 20;
    int result = add(num1,num2);
    print("%d",result);
    return 0;
}  //c언어에서는 메인함수를 시작할 때 만들어야 한다 
```
이런 식으로 절차 지향은 함수를 지속적으로 구성하며 흐른다.


## 2. 객체 지향 프로그래밍 언어 : python, Java, JS 등...

: 메서드를 하나의 객체로 묶어 관리하는 방식의 프로그래밍 패러다임

객체? 메모리에 저장되어 있는 모든 것

## 3. 객체

```python
print(type('hello')) # class<str> -> 'hello' 가 str이라는 클래스 내의 인스턴스인 객체라는 뜻.
```

### 실습1

```python
''' 실습1 : 생성자 메서드 구조로 class Singer 선언 후
1. 인스턴스 속성 출력
2. 인스턴스 메서드 호출
'''
#SHB
class Singer:
    job = '직업: 가수'
    date = '생년월일: 1993년 5월 16일'
    country = '국적: 대한민국'

    def __init__(self,name):
        self.name = name

    def 랩(self):
        print('랩하기')

    def 댄스(self):
        print('댄스 추기')

    def 소몰이(self):
        print('소몰이 부르기')
    

singer1 = Singer('IU') 

#1. 인스턴스 속성 출력 -> 속성은 멤버 변수로 
        

print(singer1.job)
print(singer1.date)
print(singer1.country)

#2. 인스턴스 메서드 호출 -> 행동(동작)은 메서드로 

singer1.랩()
singer1.댄스()
singer1.소몰이()

#-------------------------------#

#강사님

class Singer:
    
    #여기에 선언되면 클래스 변수

    def __init__(self): #생성자 메서드 : 인스턴스 변수들의 초기값을 설정

        self.occ = '가수' #멤버 변수 == 인스턴스 변수
        self.birth = '1993년 5월 16일'#멤버변수
        self.nat = '대한민국'#멤버변수
    
    #인스턴스 메서드 구조: 객체(인스턴스)의 속성에 접근할 수 있으며, self 매개변수를 통해 해당 객체에 접근한다. 
    def rap(self): 
        print('랩 하기')
    
    def dance(self):
        print('댄스 추기')
    
    def sing(self):
        print('소몰이 부르기')


#클래스 인스턴스 생성
singer = Singer()

#인스턴스 속성 출력
print('직업:',singer.occ)
print('생년월일:',singer.birth)
print('국적:',singer.nat)

#인스턴스 메서드 호출
singer.rap()
singer.dance()
singer.sing()

```
### 실습2 
my_count라는 메서드 직접 만들기
클래스명은 my_str

조건 1. 생성자 매서드 구조
조건 2. 클래스 변수와 멤버 변수 생성
조건 3. 기능은 count() 메서드와 같은 기능


```python

#shb
class my_str:
    # count = 0
    # count = 0
    def __init__(self,name):
        self.name = name #str로 만들기 위해 여기서 인스턴스 변수를 할당
        self.count = 0
        

    def my_count(self,alp):
        self.count = 0 #count 리셋
        #이거 없을 때, 여기서 새로운 인스턴스 제작 안 하고 print(banana.my_count('n')) 한 번 더 하면 누적되서 4 나와버린다.
        for char in self.name:
           
            if char == alp:
                self.count += 1
                # count += 1
            # else: 
            #     continue
        return self.count

banana = my_str('banana')

print(banana.my_count('n'))

#여기서 새로운 인스턴스 제작 안 하고 print(banana.my_count('n')) 한 번 더 하면 누적되서 4 나와버린다.
#==============

#강사님

class my_set:
    #클래스 변수 count 초기화
    count = 0
    
    def __init__(self,string):
        
        #멤버 변수 string을 생성자에서 초기화
        
        self.string = string
    
    def my_count(self,char):
        self.count = self.string.count(char) 
        # 두 count는 다른것. 전자는 변수, 후자는 str의 함수

        return self.count
    
my_str = input()
my_instance = my_set(my_str)
result = my_instance.my_count('i')
print(result)

# self.count와 self.string.count의 차이? 멤버변수 self.string 초기화 이유는?

#Q) 클래수 변수 count는 반드시 있어야 되나? A) 없어도 된다.

#-> 멤버변수로 내가 한 것처럼 하던가. 아니면 아예 선언 안 하고 함수에서 self.count = self.string.count(char) 에서 자동 선언
```

클래스 변수의 역할 : 클래스 변수로 데이터를 추적하거나 데이터를 공유

멤버변수의 역할 : 멤버 변수로 데이터를 추적하거나 데이터의 개별화


# 4. 메서드

### 실습 3

실습 1에서 했던걸 복붙해서 클래스 메서드만으로 구성되도록 바꾸기


```python

#shb
class Singer:
    job = '직업: 가수'
    date = '생년월일: 1993년 5월 16일'
    country = '국적: 대한민국'
    #클래스 메서드는 인스턴스 변수를 아예 쓰질 않으니 아예 클래스 변수로 지정

    @classmethod
    def func(cls):
        print(f'{cls.job}\n{cls.date}\n{cls.country}')
        print('랩하기')
        print('댄스 추기')
        print('소몰이 부르기')
Singer.func()

#===============================================================#

#강사님

class Singer:
    job = '가수'
    date = '1993년 5월 16일'
    country = '대한민국'
    #클래스 메서드는 인스턴스 변수를 아예 쓰질 않으니 아예 클래스 변수로 지정

    @classmethod
    def rap(cls): 
        print('랩 하기')
    
    def dance(cls):
        print('댄스 추기')
    
    def sing(cls):
        print('소몰이 부르기')

    def func(cls):
        print(f'{cls.job}\n{cls.date}\n{cls.country}')
        print('랩하기')
        print('댄스 추기')
        print('소몰이 부르기')
Singer.func()
```


### 실습 4 스태틱 메서드 
: 클래스나 인스턴스와는 무관하게 독립적으로 동작하는 메서드
(클래스 내부에서 선언되지만 클래스 변수에 접근하지 않는다)


```python
class Singer:
    
    @staticmethod
    def rap(): 
        print('랩 하기')

    @staticmethod
    def dance():
        print('댄스 추기')

    @staticmethod
    def sing():
        print('소몰이 부르기')


Singer.rap()
Singer.dance()
Singer.sing()
```


# 실습

### ws_7_b class 변수를 init으로 끌고 오기 43p 확인

```python

class Myth:
    type_of_myth = 0
    
    def __init__(self,name):
        self.name = name
        # type_of_myth += 1
        Myth.type_of_myth += 1 #클래스 변수 끌고 오기, 48p 확인
        #init 매서드에서 클래스 변수에 접근하려면 클래스명.클래스변수명 으로 접근해야한다. (init 매서드 특징)

        #인스턴스 매서드의 경우 self.type_of_myth += 1 , 클래스 매서드의 경우 cls.type_of_myth += 1 로 접근한다.
        #인스턴스의 속성 default는 class에서 갖고 오는거, 만약 self.type_of_myth가 따로 지정이 되어 있지 않다면 그 값이 class의 값으로 default됨. 그래서 이런 식으로 한 번 선언하고 가는거
    

    @staticmethod
    def description():
        print('신화는 한 나라 혹은 한 민족으로부터 전승되어 오는 예로부터 섬기는 신을 둘러싼 이야기를 뜻한다.')
        # Myth.type_of_myth += 1 , 만약 여기에 넣고 싶다면 static은 별개의 공간이므로 이런 식으로 갖고 와야함



dangun = Myth('dangun')
greek_rome = Myth('greek & rome')

print(dangun.name)
print(greek_rome.name)
print(f'현재까지 생성된 신화 수:{Myth.type_of_myth}')
Myth.description()
print(Myth.type_of_myth)
```


### ws_7_3 인스턴스 메서드의 변수와 흐름

```python
class Shape:
    def __init__(self,a,b):
        self.width = a
        self.height = b
    
    def calculate_area(self):
        area = self.width * self.height
        return area
    
    def calculate_perimeter(self):
        result = 2 * (self.width + self.height)
        return result

shape1 = Shape(5, 3)
perimeter1 = shape1.calculate_perimeter()
print(perimeter1)


'''
<인스턴스 메서드의 변수>
인스턴스가 만들어지면 init에 의해 속성(width, height)이 정해진다.

shape1 = Shape(5, 3)
shape1.calculate_perimeter()

의 경우

흐름이 shape1 생성, 동시에 shape1의 속성이 결정.
그 속성을 토대로 calculate_perimeter가 평가된다.
shape1.calculate_perimeter() == calculate(shape1)
여기서 shape1의 width, height 가 shape1에 묶여서 통으로 들어가게 되므로
우리가 따로 이를 선언하지 않고

함수에서 result = 2 * (self.width + self.height) 이런 식으로 바로 사용하는 것이다.
'''
```

### ws_7_c 변수 접근 총집합

```python
class Car:
    wheels = 4
    def __init__(self,engine,system,sound):
        self.engine = engine
        self.driving_system = system
        self.sound = sound
    def drive(self):
        print(self.sound)
        return(self.engine)
    
    def introduce(self):
        print(f'제 차의 엔진은 {self.engine} 방식이고, {self.driving_system} (으)로 동작합니다.')

    @classmethod
    def increase_wheels(cls):
        cls.wheels += 1
        print('법이 개정되어 모든 자동차의 필요 바퀴 수가 1증가하였습니다.')
        return cls.wheels
    
    @staticmethod
    def description():
        
        print('자동차(自動車, 영어: car, automobile)는 엔진에서 만든 동력을 바퀴에 전달하여 지상에서 승객이나 화물을 운반하는 교통 수단이다.')



car1 = Car('gasoline', '후륜구동', '부릉부릉')
car2 = Car('diesel', '전륜구동', '달달달달')
car3 = Car('hybrid', '4wd', '슈웅')

car1.drive()
print(car2.drive())

print('===')
car1.introduce()
car3.introduce()

print('===')
print(f'이 세상의 자동차는 {Car.wheels}개의 바퀴를 가집니다.')
Car.increase_wheels()
print(f'이 세상의 자동차는 {Car.wheels}개의 바퀴를 가집니다.')

Car.description()
```

### ws_7_4 변수 응용

```python
class Shape:
    def __init__(self,a,b):
        self.width = a
        self.height = b

    def calculate_area(self):
        area = self.width * self.height
        return area
    
    def calculate_perimeter(self):
        result = 2 * (self.width + self.height)
        return result
    
    def print_info(self):
        peimeter = self.calculate_perimeter()
        area = self.calculate_area()
        print(f'width: {self.width}\nheight: {self.height}\nArea: {area}\nPerimeter: {peimeter}')
        # 여러 함수를 def 하는 과정에서 이전에 def 했던 부분을 self를 넣어서 계산한 후, 그 값을 사용할 수도 있다.
        
shape1 = Shape(5, 3)
shape1.print_info()
```

### ws_7_5 매직 메서드

```python
class Shape:
    def __init__(self,a,b):
        self.width = a
        self.height = b

    def __str__(self):
        return f'Shape: width={self.width}, height={self.height}'
    # __str__은 print 할 때 '자동으로 호출되어' 해당 내용을 return해서 print하게 하는 메서드 
        

shape1 = Shape(5, 3)
print(shape1) # Shape: width=5, height=3
```


### hw_7_4 클래스 변수와 클래스 함수의 혼동

```python
# 아래 클래스를 수정하시오.
class Person:
    number_of_people = 0
    num = 0
    def __init__(self,name,age):
        self.name = name
        self.age = age
        Person.number_of_people += 1
        Person.num += 1

    def introduce(self):
        print(f'제 이름은 {self.name}이고, 저는 {self.age}살입니다.')
    # @classmethod #항상 클래스 메서드 만들 땐 까먹지 마라!!!!!!!!!
    # def number(cls):
    #     return cls.num

person1 = Person("Alice", 25)
person1.introduce()
print(Person.number_of_people)
# print(Person.number()) 만약 위에서 함수로 return하고 싶었다면 여기처럼 ( ) 넣어줘야함

```
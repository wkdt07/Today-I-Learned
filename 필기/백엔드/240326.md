# ORM with View

> shell에서 연습했던 걸 view 함수에서 해보자


## Read

1. 전체 게시글 조회
2. 단일 게시글 조회

### 전체 게시글 조회

## create

>create 로직을 구현하기 위해 필요한 view 함수의 개수는?

> new와 create 2개
> 사용자 입력 데이터를 받을(템플릿 제공) 페이지를 렌더링, 사용자가 입력한 데이터를 받아 DB에 저장
> 예전에 배운 throw와 catch 생각


# offline

1. post방식/GET방식 차이 : POST는 submit 버튼을 눌렀을 떄, GET은 바로 데이터를 따옴
2. render/redirect 차이
3. Django Form -> 유효성 검사 (내일 배울 내용)

QuerySet API : DB에 데이터를 CRUD하기 위한 도구(파이썬 문법)

어제) 장고 쉘을 이용해서 CRUD를 진행 -> 과목평가 안 나옴

QuerySET API를 views.py에 적용해야 함

< views.py >

1. Create : 둘로 나뉜다.
- new()
 - 페이지를 렌더링 하기 위해.(html을 필요로 함), render()
- create()
 - 페이지에서 받은 데이터를 db에 저장. redirect()

    > render()와 redirect()의 차이?

    - render() : HTML 페이지를 사용자에게 보여주는데 사용-> 즉각적인 피드백
    - redirect() : 데이터를 처리 후, 다른 url로 이동 -> 해당 url의 뷰 함수를 '다시'(re) 처리.
  
2. Read

- index : 전체 페이지 조회
- detail : 단일 페이지 조회


3. Update

- edit : 페이지 렌더링(html 필요)
- update : 데이터를 DB에 저장

4. Delete

페이지를 삭제한 후 전체 페이지로 이동해야 한다 => redirect 사용


> 주간평가는 단답형, 주관식, 서술형으로 나온다. 

## 실습

- 앱 만들었으면 settings 들어가서
   1. 앱에 django_extensions와 앱 추가
   2. 언어 코드에 'ko'
   3. 타임 존에 'Asia/Seoul'
    

- admin 처리
1. 앱의 admin.py에 다음같이 작성

```py
from django.contrib import admin

# Register your models here.

from .models import Article

admin.site.register(Article)
```

2. models에 class 작성

```py
from django.db import models

# Create your models here.
class Article(models.Model):
    title = models.CharField(max_length = 20)
    content = models.TextField()
    created_at = models.DateTimeField(auto_now_add = True)
    updated_at = models.DateTimeField(auto_now = True)
```

3. migrate

- python manage.py makemigrations
- migrate

4. createsuperuser 이후 runserver

## 본격적인 실습 시작

### 1. Read

#### < 전체 페이지 조회 >

#### url 매핑부터 

1. pjt의 urls에서 include => path('article/',include('articles.urls')),
2. 앱에 urls.py 만들고 복붙 + from . import viwes
```py
from django.contrib import admin
from django.urls import path,include
from . import viwes

app_name = 'articles'

urlpatterns = [
    path('',views.index,name = 'index'),
]
```

3. views 작성

```py
from django.shortcuts import render

# Create your views here.

from .models import Article # DB에 있는 모든 데이터가 나와야 하기 때문에

def index(request):# 전체 게시글
   articles = Article.objects.all()
   context = {
       'articles' : articles,
   } 
   return render(request,'articles/index.html',context) # 이래야 context까지 끌고간다
```

4. templates/articles 생성

5. 템플릿 상속
   1. 완전 바깥에 templates 디렉토리 만들고 base를 만들어서 block에 content라 쓴다
   2. pjt의 settings에 템플릿 상속 위치 설정
      ```py
      TEMPLATES = [
        {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            BASE_DIR,'templates'
            ],
         ``` 
   3. 원하는 템플릿에 extends "base.html"을 통해 상속 받는다. 내용 적을 땐 block content 만들어서 내부에

##### ----------------------------------------------------
#### < 단일 페이지 조회>

1. url에 변수가 들어감
    - path('<int:pk>',views.detail,name = 'detail'),

2. views 조정
   ```py
   def detail(request,pk): # 단일 게시글이니깐 정보로 pk를 추가로 받아야 함
   article = Article.objects.get(pk = pk)
   context = {
       'article' : article,
   } 
   return render(request,'articles/detail.html',context) # 이래야 context까지 끌고간다
   ```
3. html 생성 및 작성

    ```html
    {% extends "base.html" %}

    {% block content %}
    <h2>DETAIL</h2>
    <hr>
    <h3>{{article.pk}}번째 글</h3>
    <hr>
    <h3>제목 : {{article.title}}</h3>
    <h3>내용 : {{article.content}} </h3>
    <h3>작성시간 : {{article.created_at}} </h3>
    <h3>수정시간 : {{article.updated_at}}</h3>
    {% endblock content %}
    ```

> 만약 전체페이지에서 글 제목을 클릭하면 디테일 페이지로 이동할 수 있게 만드려면?
> url naming pattern
>
> 디테일 페이지에서 인덱스 페이지로 가는 [BACK] 버튼 제작도
> url naming pattern 으로 가능

```html
<!-- index.html에서 가능 -->
<a href="{% url "articles:detail" article.pk %}">
    <p>글 제목 : {{article.title}} </p>
</a>

```

```html
<!-- detail.html에서 백버튼 -->
{% comment %} 백버튼 만들기 {% endcomment %}
<a href="{% url "articles:index" %}">[BACK]</a>
```

### 2. Create

2개로 나뉜다 - new,create(제출)

```py
# urls
    [path('new/',views.new,name = 'new'),
    path('create/',views.create,name = 'create'),
]
```

```py
from django.shortcuts import render, redirect # 여기서 redirect까지 import 해줘야 한다.

# Create your views here.

from .models import Article # DB에 있는 모든 데이터가 나와야 하기 때문에

def index(request): # 전체 게시글
   articles = Article.objects.all()
   context = {
       'articles' : articles,
   } 
   return render(request,'articles/index.html',context) # 이래야 context까지 끌고간다

def detail(request,pk): # 단일 게시글이니깐 정보로 pk를 추가로 받아야 함
   article = Article.objects.get(pk = pk)
   context = {
       'article' : article,
   } 
   return render(request,'articles/detail.html',context) # 이래야 context까지 끌고간다

def new(request):
    return render(request,'articles/new.html')

def create(request):
    #데이터를 post 요청을 통해 전송. why? 보안상 안전하기 때문에
    title = request.POST.get('title')
    content = request.POST.get('content')
    
    # 코드의 간결성: 객체를 생성하면서 동시에 속성을 설정
    article = Article(title = title, content = content) # Article의 title이 여기서 작성한 title로, Article의 content가 여기서 작성한 content도록
    # 데이터 관리의 원칙 : 안정성 --> 유효성 검사!!
    article.save()
    
    return redirect('articles:detail', article.pk) 
    # 데이터가 변경 되었을 때(create가 실행되었을 때) 해당경로로 가도록 요청
```

이제 html 만들어야 한다

```html

<!-- new.html -->


{% extends "base.html" %}

{% block content %}
<h1>NEW</h1>

<form action="{% url "articles:create" %}"method = "POST">
    <!-- create로 보낼거다 -->
    {% comment %} 포스트 방식 {% endcomment %}
{% csrf_token %}
{% comment %} form 태그 쓰면 csrf 토큰을 무조건 만들어줘야한다. {% endcomment %}
<div>
    <label for="title">Title : </label>
    <input type="text" name = 'title' id='title'>
</div>
<div>
    <label for="content">
        Content : 
    </label>
    <textarea name="content" id="content" cols="30" rows="10"></textarea>
    
</div>

{% comment %} 제출버튼 {% endcomment %}
<input type="submit"> 
{% comment %} 이걸 눌러야 데이터가 csrf_token에 전달된다. POST 방식으로 {% endcomment %}
<!-- submit을 눌러야 action이 되어서 create가 실행된다.(create은 함수 이름) -->

</form>
{% endblock content %}
```

### 3. Delete


1. urls

path('<int:pk>/delete/', views.delete, name = 'delete'),


2. views
```python

def delete(request,pk): # 특정 단일 페이지만 삭제해야 하므로 인자로 pk를 받는다
    article = Article.objects.get(pk = pk)
    article.delete()
    
    return redirect('articles:index')
``` 

3. html

```html

<!-- detail -->

{% extends "base.html" %}

{% block content %}
<h2>DETAIL</h2>
<hr>
<h3>{{article.pk}}번째 글</h3>
<hr>
<h3>제목 : {{article.title}}</h3>
<h3>내용 : {{article.content}} </h3>
<h3>작성시간 : {{article.created_at}} </h3>
<h3>수정시간 : {{article.updated_at}}</h3>

{% comment %} 백버튼 만들기 {% endcomment %}
<a href="{% url "articles:index" %}">[BACK]</a>

{% comment %} 삭제 버튼 만들기 {% endcomment %}
<form action="{% url "articles:delete" article.pk%}"method = 'POST'>
    {% csrf_token %}
    <input type="submit" value = "DELETE">
</form>
{% endblock content %}
```

### 4. Update

1. urls

    path('<int:pk>/edit/',views.edit, name = 'edit'),
    path('<int:pk>/update/',views.update,name = 'update'),

2. views

```py
def edit(request,pk): # 있던걸 수정한다는 점에서 create과 다름
    article = Article.objects.get(pk=pk)
    context = {
        'article' : article
    }
    
    return render(request,'articles/edit.html',context) # 수정하는 html로 렌더링

def update(request,pk): # create와 거의 유사, 다만 기존에 있던걸 가져와야 하니 pk를 갖고온다
    # title = request.POST.get('title')
    # content = request.POST.get('content')
    
    # 기존에 있던걸 갖고와야 하니깐
    article = Article.objects.get(pk = pk)
    
    article.title = request.POST.get('title')
    article.content = request.POST.get('content')
    
    article.save()
    
    return redirect('articles:detail', article.pk)
```

3. html

```html
<!-- edit.html -->

{% extends "base.html" %}

{% comment %} create과 거의 유사 {% endcomment %}



{% block content %}
<h1>EDIT</h1>

<form action="{% url "articles:update" article.pk %}" method = "POST">
    {% comment %} 포스트 방식 {% endcomment %}
{% csrf_token %}
{% comment %} form 태그 쓰면 csrf 토큰을 무조건 만들어줘야한다. {% endcomment %}
<div>
    <label for="title">Title : </label>
    <input type="text" name = 'title' id='title' value = {{article.title}}>
    {% comment %} value는 초기값. 그래서 이걸 가져와야함  {% endcomment %}
</div>
<div>
    <label for="content">
        Content : 
    </label>
    <textarea name="content" id="content" {{article.content}} cols="30" rows="10"></textarea>
    
</div>

{% comment %} 제출버튼 {% endcomment %}
<input type="submit"> 
{% comment %} 이걸 눌러야 데이터가 csrf_token에 전달된다. POST 방식으로 {% endcomment %}

</form>

<hr>

<a href="{% url "articles:index" %}">[back]</a>
{% endblock content %}
```

```html
<!-- detail에 버튼 만들기 -->

<a href="{% url "articles:edit" article.pk %}">EDIT</a>

```

